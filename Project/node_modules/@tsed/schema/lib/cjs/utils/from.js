"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enums = exports.lazyRef = exports.allOf = exports.oneOf = exports.anyOf = exports.any = exports.object = exports.set = exports.map = exports.array = exports.url = exports.uri = exports.email = exports.time = exports.datetime = exports.date = exports.boolean = exports.string = exports.integer = exports.number = exports.from = void 0;
const core_1 = require("@tsed/core");
const JsonEntityStore_1 = require("../domain/JsonEntityStore");
const JsonFormatTypes_1 = require("../domain/JsonFormatTypes");
const JsonLazyRef_1 = require("../domain/JsonLazyRef");
const JsonSchema_1 = require("../domain/JsonSchema");
const enumRegistries_1 = require("../registries/enumRegistries");
const getJsonEntityStore_1 = require("./getJsonEntityStore");
/**
 * Create a new model from the given type.
 *
 * ```typescript
 * from(String)
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function from(type = Object) {
    if ((0, core_1.isClass)(type)) {
        const { schema } = (0, getJsonEntityStore_1.getJsonEntityStore)(type);
        schema.properties = function properties(obj) {
            Object.entries(obj).forEach(([propertyKey, propSchema]) => {
                (0, getJsonEntityStore_1.getJsonEntityStore)(type.prototype, propertyKey).schema.assign(propSchema);
            });
            return this;
        };
        return schema;
    }
    return JsonSchema_1.JsonSchema.from({ type });
}
exports.from = from;
/**
 * Declare a new number model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function number() {
    return from(Number);
}
exports.number = number;
/**
 * Declare a new integer model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function integer() {
    return from(Number).integer();
}
exports.integer = integer;
/**
 * Declare a new string model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function string() {
    return from(String);
}
exports.string = string;
/**
 * Declare a new boolean model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function boolean() {
    return from(Boolean);
}
exports.boolean = boolean;
/**
 * Declare a new string model with `format: date`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function date() {
    return from(Date).format(JsonFormatTypes_1.JsonFormatTypes.DATE);
}
exports.date = date;
/**
 * Declare a new string model with `format: datetime`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function datetime() {
    return from(Date).format(JsonFormatTypes_1.JsonFormatTypes.DATE_TIME);
}
exports.datetime = datetime;
/**
 * Declare a new string model with `format: time`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function time() {
    return from(Date).format(JsonFormatTypes_1.JsonFormatTypes.TIME);
}
exports.time = time;
/**
 * Declare a new string model with `format: email`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function email() {
    return from(String).format(JsonFormatTypes_1.JsonFormatTypes.EMAIL);
}
exports.email = email;
/**
 * Declare a new string model with `format: uri`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function uri() {
    return from(String).format(JsonFormatTypes_1.JsonFormatTypes.URI);
}
exports.uri = uri;
/**
 * Declare a new string model with `format: url`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function url() {
    return from(String).format(JsonFormatTypes_1.JsonFormatTypes.URL);
}
exports.url = url;
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "array"
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function array() {
    return from(Array);
}
exports.array = array;
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "object",
 *   "additionalProperties": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function map() {
    return from(Map).unknown(true);
}
exports.map = map;
/**
 * Declare a new array model with `uniqueItems: true`.
 *
 * ```json
 * {
 *   "type": "array",
 *   "uniqueItems": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function set() {
    return from(Array).uniqueItems(true);
}
exports.set = set;
/**
 * Declare a new object model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function object(properties = {}) {
    return from(Object).properties(properties);
}
exports.object = object;
/**
 * Declare a model with any type (By default: `integer`, `number`, `string`, `boolean`, `array`, `object`, `null`)
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function any(...types) {
    return from().any(...types);
}
exports.any = any;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 * @schemaFunctional
 */
function anyOf(...anyOf) {
    return from().anyOf(anyOf);
}
exports.anyOf = anyOf;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 */
function oneOf(...oneOf) {
    return from().oneOf(oneOf);
}
exports.oneOf = oneOf;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 * @schemaFunctional
 */
function allOf(...allOf) {
    return from().allOf(allOf);
}
exports.allOf = allOf;
/**
 * Declare a sub schema which will be resolved later. Use this function when you have a circular reference between two schemes.
 *
 * @schemaFunctional
 */
function lazyRef(cb) {
    try {
        // solve issue with a self referenced model
        if (cb()) {
            // type is already accessible
            return JsonEntityStore_1.JsonEntityStore.from(cb()).schema;
        }
    }
    catch (er) { }
    return new JsonLazyRef_1.JsonLazyRef(cb);
}
exports.lazyRef = lazyRef;
function enums(e) {
    const schema = string().enum(e);
    enumRegistries_1.enumsRegistry.set(e, schema);
    return schema;
}
exports.enums = enums;
//# sourceMappingURL=from.js.map