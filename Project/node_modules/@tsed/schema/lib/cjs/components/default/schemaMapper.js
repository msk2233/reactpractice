"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaMapper = void 0;
const core_1 = require("@tsed/core");
const JsonAliasMap_1 = require("../../domain/JsonAliasMap");
const SpecTypes_1 = require("../../domain/SpecTypes");
const alterOneOf_1 = require("../../hooks/alterOneOf");
const JsonSchemaMapperContainer_1 = require("../../registries/JsonSchemaMapperContainer");
const getRequiredProperties_1 = require("../../utils/getRequiredProperties");
const inlineEnums_1 = require("../../utils/inlineEnums");
const mapNullableType_1 = require("../../utils/mapNullableType");
/**
 * @ignore
 */
const IGNORES = ["name", "$required", "$hooks", "_nestedGenerics", SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER, SpecTypes_1.SpecTypes.JSON];
/**
 * @ignore
 */
const IGNORES_OPENSPEC = ["const"];
/**
 * @ignore
 */
function isEmptyProperties(key, value) {
    return typeof value === "object" && ["items", "properties", "additionalProperties"].includes(key) && Object.keys(value).length === 0;
}
/**
 * @ignore
 */
function shouldMapAlias(key, value, useAlias) {
    return typeof value === "object" && useAlias && ["properties", "additionalProperties"].includes(key);
}
/**
 * @ignore
 */
function shouldSkipKey(key, { specType = SpecTypes_1.SpecTypes.JSON, customKeys = false }) {
    return (IGNORES.includes(key) ||
        (key.startsWith("#") && (customKeys === false || specType !== SpecTypes_1.SpecTypes.JSON)) ||
        (specType !== SpecTypes_1.SpecTypes.JSON && IGNORES_OPENSPEC.includes(key)));
}
function isExample(key, value, options) {
    return key === "examples" && (0, core_1.isObject)(value) && [SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.ASYNCAPI].includes(options.specType);
}
function mapOptions(options) {
    let addDef = false;
    if (!options) {
        addDef = true;
        options = { components: { schemas: {} }, inlineEnums: true };
    }
    const { useAlias = true, components = { schemas: {} } } = options;
    options = {
        ...options,
        useAlias,
        components
    };
    return {
        addDef,
        options
    };
}
function mapKeys(schema, options) {
    const { useAlias } = options;
    return [...schema.keys()]
        .filter((key) => !shouldSkipKey(key, options))
        .reduce((item, key) => {
        let value = schema.get(key);
        key = key.replace(/^#/, "");
        if (key === "type") {
            return {
                ...item,
                [key]: schema.getJsonType()
            };
        }
        if (isExample(key, value, options)) {
            key = "example";
            value = Object.values(value)[0];
        }
        if (value && typeof value === "object" && (0, JsonSchemaMapperContainer_1.hasMapper)(key)) {
            value = (0, JsonSchemaMapperContainer_1.execMapper)(key, [value], options, schema);
            if (isEmptyProperties(key, value)) {
                return item;
            }
            if (shouldMapAlias(key, value, useAlias)) {
                value = (0, JsonAliasMap_1.mapAliasedProperties)(value, schema.alias);
            }
        }
        return {
            ...item,
            [key]: value
        };
    }, {});
}
function serializeSchema(schema, options) {
    let obj = mapKeys(schema, options);
    if (schema.isClass) {
        obj = (0, JsonSchemaMapperContainer_1.execMapper)("inheritedClass", [obj], {
            ...options,
            root: false,
            target: schema.getComputedType()
        });
    }
    obj = (0, JsonSchemaMapperContainer_1.execMapper)("generics", [obj], {
        ...options,
        root: false
    });
    if (schema.has(options.specType)) {
        obj = {
            ...obj,
            ...schema.get(options.specType).toJSON(options)
        };
    }
    obj = (0, getRequiredProperties_1.getRequiredProperties)(obj, schema, options);
    obj = (0, mapNullableType_1.mapNullableType)(obj, schema, options);
    obj = (0, alterOneOf_1.alterOneOf)(obj, schema, options);
    obj = (0, inlineEnums_1.inlineEnums)(obj, schema, options);
    return obj;
}
function schemaMapper(schema, opts) {
    const { options, addDef } = mapOptions(opts);
    const obj = serializeSchema(schema, options);
    if (addDef && Object.keys((0, core_1.getValue)(options, "components.schemas", {})).length) {
        obj.definitions = options.components.schemas;
    }
    return obj;
}
exports.schemaMapper = schemaMapper;
(0, JsonSchemaMapperContainer_1.registerJsonSchemaMapper)("schema", schemaMapper);
//# sourceMappingURL=schemaMapper.js.map