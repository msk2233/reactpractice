"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParamMetadata = exports.JsonParameterStore = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const JsonEntityStore_1 = require("./JsonEntityStore");
const JsonParameter_1 = require("./JsonParameter");
const JsonSchema_1 = require("./JsonSchema");
const jsonEntityComponent_1 = require("../decorators/config/jsonEntityComponent");
let JsonParameterStore = class JsonParameterStore extends JsonEntityStore_1.JsonEntityStore {
    paramType;
    expression;
    dataPath;
    /**
     * Define pipes can be called by the framework to transform input parameter
     */
    pipes;
    /**
     * Ref to JsonParameter when the decorated object is a parameter.
     */
    parameter = new JsonParameter_1.JsonParameter();
    parent = JsonEntityStore_1.JsonEntityStore.fromMethod(this.target, this.propertyKey);
    constructor(options) {
        super(options);
        this.pipes = options.pipes || [];
        this.paramType = options.paramType || this.paramType;
        this.expression = options.expression || this.expression;
        this.dataPath = options.dataPath || this.dataPath;
    }
    get nestedGenerics() {
        return this.parameter.nestedGenerics;
    }
    set nestedGenerics(nestedGenerics) {
        this.parameter.nestedGenerics = nestedGenerics;
    }
    /**
     * Return the required state.
     * @returns {boolean}
     */
    get required() {
        return !!this.parameter.get("required");
    }
    set required(value) {
        this.parameter.required(value);
    }
    get allowedRequiredValues() {
        return this.schema.$allow;
    }
    static getParams(target, propertyKey) {
        const params = [];
        const klass = (0, core_1.ancestorsOf)(target)
            .reverse()
            .find((target) => {
            return (0, core_1.isMethodDescriptor)(target, propertyKey) && JsonEntityStore_1.JsonEntityStore.fromMethod(target, propertyKey).children.size;
        });
        if (klass) {
            JsonEntityStore_1.JsonEntityStore.fromMethod(klass, propertyKey).children.forEach((param, index) => {
                params[+index] = param;
            });
            return params;
        }
        return [];
    }
    static get(target, propertyKey, index) {
        return JsonEntityStore_1.JsonEntityStore.from((0, core_1.prototypeOf)(target), propertyKey, index);
    }
    /**
     * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
     * @param value
     * @returns {boolean}
     */
    isRequired(value) {
        return this.required && [undefined, null, ""].includes(value) && !this.allowedRequiredValues.includes(value);
    }
    getSchema(type) {
        if ((0, core_1.isCollection)(type) || !(0, core_1.isClass)(type)) {
            return JsonSchema_1.JsonSchema.from({
                type
            });
        }
        return JsonEntityStore_1.JsonEntityStore.from(type).schema;
    }
    build() {
        if (!this._type) {
            const type = core_1.Metadata.getParamTypes((0, core_1.prototypeOf)(this.target), this.propertyKey)[this.index];
            this.buildType(type);
        }
        this._type = this._type || Object;
        if (!this._schema) {
            this.parent.children.set(this.index, this);
            this._schema = this.getSchema(this.collectionType || this.type);
            this.parameter.schema(this._schema);
            if (this.collectionType) {
                this._schema.itemSchema(this.getSchema(this.type));
            }
            this.parent.operation.addParameter(this.index, this.parameter);
        }
    }
};
JsonParameterStore = tslib_1.__decorate([
    (0, jsonEntityComponent_1.JsonEntityComponent)(core_1.DecoratorTypes.PARAM),
    tslib_1.__metadata("design:paramtypes", [Object])
], JsonParameterStore);
exports.JsonParameterStore = JsonParameterStore;
exports.ParamMetadata = JsonParameterStore;
//# sourceMappingURL=JsonParameterStore.js.map