"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointMetadata = exports.JsonMethodStore = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const jsonEntityComponent_1 = require("../decorators/config/jsonEntityComponent");
const JsonEntityStore_1 = require("./JsonEntityStore");
const JsonOperation_1 = require("./JsonOperation");
const JsonSchema_1 = require("./JsonSchema");
let JsonMethodStore = class JsonMethodStore extends JsonEntityStore_1.JsonEntityStore {
    parent = JsonEntityStore_1.JsonEntityStore.from(this.target);
    middlewares = [];
    beforeMiddlewares = [];
    afterMiddlewares = [];
    /**
     * Ref to JsonOperation when the decorated object is a method.
     */
    operation = new JsonOperation_1.JsonOperation();
    /**
     * List of children JsonEntityStore (properties or methods or params)
     */
    children = new Map();
    constructor(options) {
        super({
            store: core_1.Store.fromMethod(options.target, options.propertyKey),
            descriptor: (0, core_1.descriptorOf)(options.target, options.propertyKey),
            ...options
        });
        const { beforeMiddlewares = [], middlewares = [], afterMiddlewares = [] } = options;
        this.after(afterMiddlewares);
        this.before(beforeMiddlewares);
        this.use(middlewares);
    }
    get params() {
        return this.parameters;
    }
    get view() {
        return this.store.get("view");
    }
    set view(view) {
        this.store.set("view", view);
    }
    get acceptMimes() {
        return this.store.get("acceptMimes", []);
    }
    set acceptMimes(mimes) {
        this.store.set("acceptMimes", mimes);
    }
    get parameters() {
        return [...this.children.values()];
    }
    get operationPaths() {
        return this.operation.operationPaths;
    }
    /**
     * Get an endpoint.
     * @param target
     * @param propertyKey
     * @param descriptor
     */
    static get(target, propertyKey, descriptor) {
        descriptor = descriptor || (0, core_1.descriptorOf)((0, core_1.prototypeOf)(target), propertyKey);
        return JsonEntityStore_1.JsonEntityStore.from((0, core_1.prototypeOf)(target), propertyKey, descriptor);
    }
    getResponseOptions(status, { contentType = "application/json", includes } = {}) {
        const media = this.operation.getResponseOf(status).getMedia(contentType, false);
        if (media && media.has("schema")) {
            const schema = media.get("schema");
            let groups = media.groups;
            if (includes && media.allowedGroups?.size) {
                groups = [...(groups || []), ...includes.filter((include) => media.allowedGroups.has(include))];
            }
            return { type: schema.getComputedItemType(), groups };
        }
        return { type: this.type };
    }
    /**
     * Append middlewares to the beforeMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    before(args) {
        this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Append middlewares to the afterMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    after(args) {
        this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     */
    use(args) {
        this.middlewares = this.middlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Find the value at the controller level. Let this value be extended or overridden by the endpoint itself.
     *
     * @param key
     * @returns {any}
     */
    get(key) {
        const ctrlValue = core_1.Store.from(this.target).get(key);
        return (0, core_1.deepMerge)(ctrlValue, this.store.get(key));
    }
    getParamTypes() {
        return [...this.children.values()].reduce((obj, item) => ({
            ...obj,
            [item.paramType]: true
        }), {});
    }
    build() {
        if (!this._type) {
            let type = core_1.Metadata.getReturnType(this.target, this.propertyKey);
            type = (0, core_1.isPromise)(type) ? undefined : type;
            this.buildType(type);
        }
        this._type = this._type || Object;
        this.parent.children.set(this.propertyName, this);
        if ((0, core_1.isCollection)(this._type)) {
            this.collectionType = this._type;
            // @ts-ignore
            delete this._type;
        }
        this._schema = JsonSchema_1.JsonSchema.from({
            type: this.collectionType || this.type
        });
        if (this.collectionType) {
            this._schema.itemSchema(this.type);
        }
        this.parent.schema.addProperty(this.propertyName, this.schema);
    }
};
JsonMethodStore = tslib_1.__decorate([
    (0, jsonEntityComponent_1.JsonEntityComponent)(core_1.DecoratorTypes.METHOD),
    tslib_1.__metadata("design:paramtypes", [Object])
], JsonMethodStore);
exports.JsonMethodStore = JsonMethodStore;
exports.EndpointMetadata = JsonMethodStore;
//# sourceMappingURL=JsonMethodStore.js.map