import { decorateMethodsOf, decoratorTypeOf, DecoratorTypes, isArray, isCollection, isObject, isPlainObject, isPrimitiveOrPrimitiveClass, isString } from "@tsed/core";
import { getStatusMessage } from "../../constants/httpStatusMessages.js";
import { DecoratorContext } from "../../domain/DecoratorContext.js";
import { JsonEntityStore } from "../../domain/JsonEntityStore.js";
import { JsonParameter } from "../../domain/JsonParameter.js";
import { JsonSchema } from "../../domain/JsonSchema.js";
import { getStatusModel } from "../../utils/defineStatusModel.js";
import { string } from "../../utils/from.js";
import { isSuccessStatus } from "../../utils/isSuccessStatus.js";
import { mapHeaders } from "../../utils/mapHeaders.js";
/**
 * @ignore
 */
function isEnum(type) {
    return isObject(type) && !("toJSON" in type);
}
function mapGenerics(types) {
    return types.map((type) => {
        if (isEnum(type)) {
            return string().enum(Object.values(type));
        }
        return type;
    });
}
/**
 * @ignore
 */
class ReturnDecoratorContext extends DecoratorContext {
    methods = [
        "contentType",
        "description",
        "examples",
        "type",
        "status",
        "of",
        "ofInteger",
        "oneOf",
        "allOf",
        "anyOf",
        "nested",
        "header",
        "headers",
        "schema",
        "title",
        "groups",
        "allowedGroups",
        "location"
    ];
    constructor({ status, model }) {
        super();
        this.model(model);
        this.status(status);
    }
    type(model) {
        return this.model(model);
    }
    model(model) {
        model && this.set("model", model);
        return this;
    }
    status(status) {
        this.set("status", status);
        if (status && getStatusMessage(status) && !this.get("description")) {
            this.set("description", getStatusMessage(status));
            if (!this.get("model")) {
                this.model(getStatusModel(+status));
            }
        }
        return this;
    }
    headers(headers) {
        this.set("headers", {
            ...(this.get("headers") || {}),
            ...mapHeaders(headers)
        });
        return this;
    }
    header(key, value) {
        if (value === undefined && isString(key)) {
            return this.headers({ [key]: { type: "string" } });
        }
        return this.headers({ [key]: value });
    }
    location(path, meta = {}) {
        this.headers({
            Location: {
                ...meta,
                value: path
            }
        });
        return this;
    }
    groups(...groups) {
        if (groups.length === 2 && isArray(groups[1])) {
            this.set("groupsName", groups[0]);
            this.set("groups", groups[1]);
        }
        else {
            this.set("groups", groups);
        }
        return this;
    }
    allowedGroups(...allowedGroups) {
        this.set("allowedGroups", new Set(allowedGroups));
        return this;
    }
    nested(...generics) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.checkCollection(model);
        this.addAction((ctx) => {
            this.get("schema").nestedGenerics.push(mapGenerics(generics));
        });
        return this;
    }
    of(...types) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.addAction(() => {
            const schema = this.get("schema");
            if (isCollection(model)) {
                schema?.itemSchema({ type: types[0] });
            }
            else {
                schema?.nestedGenerics.push(mapGenerics(types));
            }
        });
        return this;
    }
    ofInteger() {
        return this.of("integer");
    }
    oneOf(...types) {
        return this.manyOf("oneOf", types);
    }
    allOf(...types) {
        return this.manyOf("allOf", types);
    }
    anyOf(...types) {
        return this.manyOf("anyOf", types);
    }
    schema(partial) {
        this.addAction(() => {
            const schema = this.get("schema");
            schema.assign(partial);
        });
        return this;
    }
    examples(examples) {
        this.set("examples", isString(examples) ? [examples] : examples);
        return this;
    }
    title(title) {
        return this.schema({ title });
    }
    checkPrimitive(model) {
        if (isPrimitiveOrPrimitiveClass(model)) {
            throw new Error("Returns.Of cannot be used with the following primitive classes: String, Number, Boolean");
        }
    }
    checkCollection(model) {
        if (isCollection(model)) {
            throw new Error("Returns.Nested cannot be used with the following classes: Map, Set, Array, String, Number, Boolean");
        }
    }
    getContentType() {
        const model = this.get("model");
        let contentType = this.get("contentType");
        if (model && !isPlainObject(model) && !isPrimitiveOrPrimitiveClass(model)) {
            contentType = contentType || "application/json";
        }
        return contentType;
    }
    getStatus() {
        return this.get("status") || "default";
    }
    onInit(args, decorator) {
        const type = decoratorTypeOf(args);
        switch (type) {
            case DecoratorTypes.METHOD:
                this.entity = JsonEntityStore.from(...args);
                if (this.entity.operation) {
                    this.map();
                }
                break;
            case DecoratorTypes.CLASS:
                this.decoratorType = DecoratorTypes.CLASS;
                decorateMethodsOf(args[0], decorator);
                break;
        }
    }
    map() {
        const model = this.get("model");
        const { entity, decoratorType } = this;
        const operation = this.entity.operation;
        const currentStatus = this.getStatus();
        const response = operation.ensureResponseOf(currentStatus);
        const contentType = this.getContentType();
        let { description = response.get("description") } = this.toObject();
        if (description) {
            description = decoratorType === DecoratorTypes.CLASS ? response.get("description") || description : description;
            response.description(description);
        }
        const headers = this.getMergedKey("headers", response.get("headers"));
        if (headers) {
            response.headers(headers);
        }
        this.mapMedia(response);
        if (isSuccessStatus(this.get("status")) || currentStatus === "default") {
            if (model) {
                entity.type = model;
            }
        }
        // additional info for OS2
        contentType && operation.addProduce(contentType);
        // run additional actions
        return this.runActions();
    }
    mapMedia(response) {
        const contentType = this.getContentType();
        const model = this.get("model");
        const media = response.getMedia(contentType || "*/*");
        const schema = media.get("schema") || new JsonSchema({ type: model });
        const groups = this.get("groups");
        const groupsName = this.get("groupsName");
        const allowedGroups = this.get("allowedGroups");
        const operation = this.entity.operation;
        if (model) {
            if (isArray(model)) {
                schema.oneOf(model.map((type) => ({ type })));
            }
            else {
                schema.type(model);
            }
        }
        this.set("schema", schema);
        media.schema(schema);
        media.groups = groups;
        media.groupsName = groupsName;
        if (allowedGroups) {
            media.allowedGroups = allowedGroups;
            const jsonParameter = new JsonParameter();
            jsonParameter.in("query").name("includes");
            jsonParameter.schema(JsonSchema.from({
                type: "array",
                items: {
                    type: "string",
                    enum: [...allowedGroups]
                }
            }));
            operation.addParameter(-1, jsonParameter);
        }
        const examples = this.get("examples");
        if (examples) {
            media.examples(examples);
        }
        return media;
    }
    manyOf(kind, types) {
        const model = this.get("model");
        this.addAction(() => {
            const schema = this.get("schema");
            if (isCollection(model)) {
                schema.type(model || Object);
                schema.itemSchema().set(kind, types);
            }
            else {
                schema.set(kind, types);
            }
        });
        return this;
    }
}
export function Returns(status, model) {
    const context = new ReturnDecoratorContext({
        status,
        model
    });
    return context.build();
}
//# sourceMappingURL=returns.js.map