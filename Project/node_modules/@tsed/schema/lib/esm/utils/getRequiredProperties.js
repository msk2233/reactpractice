import { uniq } from "@tsed/core";
import { alterRequiredGroups } from "../hooks/alterRequiredGroups.js";
function applyStringRule(obj, propSchema) {
    if (!propSchema?.$allow.includes("")) {
        if ([].concat(propSchema?.get("type")).includes("string")) {
            const minLength = obj?.minLength;
            // Disallow empty string
            if (minLength === undefined) {
                return {
                    ...obj,
                    minLength: 1
                };
            }
        }
    }
    return obj;
}
function mapRequiredProps(obj, schema, options = {}) {
    const { useAlias } = options;
    const props = Object.keys(obj.properties || {});
    return (keys, key) => {
        const aliasedKey = useAlias ? schema.alias.get(key) || key : key;
        if (props.includes(aliasedKey)) {
            const propSchema = schema.get("properties")[key];
            const serializeSchema = obj.properties[aliasedKey];
            obj.properties[aliasedKey] = applyStringRule(serializeSchema, propSchema);
            return keys.concat(aliasedKey);
        }
        return keys;
    };
}
function extractRequiredProps(obj, schema, options) {
    let required = obj.required || [];
    required = [...required, ...schema.$required];
    if (schema.get("properties")) {
        required = Object.entries(schema.get("properties")).reduce((required, [key, prop]) => {
            if (prop && prop.$selfRequired !== undefined) {
                return prop.$selfRequired ? required.concat(key) : required.filter((k) => k === key);
            }
            return required;
        }, required);
    }
    return alterRequiredGroups(uniq(required), schema, options);
}
/**
 * @ignore
 */
export function getRequiredProperties(obj, schema, options) {
    if (options.groups && options.groups.includes("partial")) {
        if (obj.discriminator) {
            return {
                ...obj,
                required: [obj.discriminator.propertyName]
            };
        }
        return obj;
    }
    let required = extractRequiredProps(obj, schema, options);
    required = uniq(required).reduce(mapRequiredProps(obj, schema, options), []);
    if (obj.discriminator) {
        required.push(obj.discriminator.propertyName);
    }
    if (required.length) {
        return {
            ...obj,
            required
        };
    }
    return obj;
}
//# sourceMappingURL=getRequiredProperties.js.map