import { __decorate, __metadata } from "tslib";
import { DecoratorTypes, deepMerge, descriptorOf, isCollection, isFunction, isPromise, Metadata, prototypeOf, Store } from "@tsed/core";
import { JsonEntityComponent } from "../decorators/config/jsonEntityComponent.js";
import { JsonEntityStore } from "./JsonEntityStore.js";
import { JsonOperation } from "./JsonOperation.js";
import { JsonSchema } from "./JsonSchema.js";
let JsonMethodStore = class JsonMethodStore extends JsonEntityStore {
    parent = JsonEntityStore.from(this.target);
    middlewares = [];
    beforeMiddlewares = [];
    afterMiddlewares = [];
    /**
     * Ref to JsonOperation when the decorated object is a method.
     */
    operation = new JsonOperation();
    /**
     * List of children JsonEntityStore (properties or methods or params)
     */
    children = new Map();
    constructor(options) {
        super({
            store: Store.fromMethod(options.target, options.propertyKey),
            descriptor: descriptorOf(options.target, options.propertyKey),
            ...options
        });
        const { beforeMiddlewares = [], middlewares = [], afterMiddlewares = [] } = options;
        this.after(afterMiddlewares);
        this.before(beforeMiddlewares);
        this.use(middlewares);
    }
    get params() {
        return this.parameters;
    }
    get view() {
        return this.store.get("view");
    }
    set view(view) {
        this.store.set("view", view);
    }
    get acceptMimes() {
        return this.store.get("acceptMimes", []);
    }
    set acceptMimes(mimes) {
        this.store.set("acceptMimes", mimes);
    }
    get parameters() {
        return [...this.children.values()];
    }
    get operationPaths() {
        return this.operation.operationPaths;
    }
    /**
     * Get an endpoint.
     * @param target
     * @param propertyKey
     * @param descriptor
     */
    static get(target, propertyKey, descriptor) {
        descriptor = descriptor || descriptorOf(prototypeOf(target), propertyKey);
        return JsonEntityStore.from(prototypeOf(target), propertyKey, descriptor);
    }
    getResponseOptions(status, { contentType = "application/json", includes } = {}) {
        const media = this.operation.getResponseOf(status).getMedia(contentType, false);
        if (media && media.has("schema")) {
            const schema = media.get("schema");
            let groups = media.groups;
            if (includes && media.allowedGroups?.size) {
                groups = [...(groups || []), ...includes.filter((include) => media.allowedGroups.has(include))];
            }
            return { type: schema.getComputedItemType(), groups };
        }
        return { type: this.type };
    }
    /**
     * Append middlewares to the beforeMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    before(args) {
        this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(isFunction);
        return this;
    }
    /**
     * Append middlewares to the afterMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    after(args) {
        this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(isFunction);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     */
    use(args) {
        this.middlewares = this.middlewares.concat(args).filter(isFunction);
        return this;
    }
    /**
     * Find the value at the controller level. Let this value be extended or overridden by the endpoint itself.
     *
     * @param key
     * @returns {any}
     */
    get(key) {
        const ctrlValue = Store.from(this.target).get(key);
        return deepMerge(ctrlValue, this.store.get(key));
    }
    getParamTypes() {
        return [...this.children.values()].reduce((obj, item) => ({
            ...obj,
            [item.paramType]: true
        }), {});
    }
    build() {
        if (!this._type) {
            let type = Metadata.getReturnType(this.target, this.propertyKey);
            type = isPromise(type) ? undefined : type;
            this.buildType(type);
        }
        this._type = this._type || Object;
        this.parent.children.set(this.propertyName, this);
        if (isCollection(this._type)) {
            this.collectionType = this._type;
            // @ts-ignore
            delete this._type;
        }
        this._schema = JsonSchema.from({
            type: this.collectionType || this.type
        });
        if (this.collectionType) {
            this._schema.itemSchema(this.type);
        }
        this.parent.schema.addProperty(this.propertyName, this.schema);
    }
};
JsonMethodStore = __decorate([
    JsonEntityComponent(DecoratorTypes.METHOD),
    __metadata("design:paramtypes", [Object])
], JsonMethodStore);
export { JsonMethodStore };
export const EndpointMetadata = JsonMethodStore;
//# sourceMappingURL=JsonMethodStore.js.map