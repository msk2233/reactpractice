import { __decorate, __metadata } from "tslib";
import { ancestorsOf, DecoratorTypes, isClass, isCollection, isMethodDescriptor, Metadata, prototypeOf } from "@tsed/core";
import { JsonEntityStore } from "./JsonEntityStore.js";
import { JsonParameter } from "./JsonParameter.js";
import { JsonSchema } from "./JsonSchema.js";
import { JsonEntityComponent } from "../decorators/config/jsonEntityComponent.js";
let JsonParameterStore = class JsonParameterStore extends JsonEntityStore {
    paramType;
    expression;
    dataPath;
    /**
     * Define pipes can be called by the framework to transform input parameter
     */
    pipes;
    /**
     * Ref to JsonParameter when the decorated object is a parameter.
     */
    parameter = new JsonParameter();
    parent = JsonEntityStore.fromMethod(this.target, this.propertyKey);
    constructor(options) {
        super(options);
        this.pipes = options.pipes || [];
        this.paramType = options.paramType || this.paramType;
        this.expression = options.expression || this.expression;
        this.dataPath = options.dataPath || this.dataPath;
    }
    get nestedGenerics() {
        return this.parameter.nestedGenerics;
    }
    set nestedGenerics(nestedGenerics) {
        this.parameter.nestedGenerics = nestedGenerics;
    }
    /**
     * Return the required state.
     * @returns {boolean}
     */
    get required() {
        return !!this.parameter.get("required");
    }
    set required(value) {
        this.parameter.required(value);
    }
    get allowedRequiredValues() {
        return this.schema.$allow;
    }
    static getParams(target, propertyKey) {
        const params = [];
        const klass = ancestorsOf(target)
            .reverse()
            .find((target) => {
            return isMethodDescriptor(target, propertyKey) && JsonEntityStore.fromMethod(target, propertyKey).children.size;
        });
        if (klass) {
            JsonEntityStore.fromMethod(klass, propertyKey).children.forEach((param, index) => {
                params[+index] = param;
            });
            return params;
        }
        return [];
    }
    static get(target, propertyKey, index) {
        return JsonEntityStore.from(prototypeOf(target), propertyKey, index);
    }
    /**
     * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
     * @param value
     * @returns {boolean}
     */
    isRequired(value) {
        return this.required && [undefined, null, ""].includes(value) && !this.allowedRequiredValues.includes(value);
    }
    getSchema(type) {
        if (isCollection(type) || !isClass(type)) {
            return JsonSchema.from({
                type
            });
        }
        return JsonEntityStore.from(type).schema;
    }
    build() {
        if (!this._type) {
            const type = Metadata.getParamTypes(prototypeOf(this.target), this.propertyKey)[this.index];
            this.buildType(type);
        }
        this._type = this._type || Object;
        if (!this._schema) {
            this.parent.children.set(this.index, this);
            this._schema = this.getSchema(this.collectionType || this.type);
            this.parameter.schema(this._schema);
            if (this.collectionType) {
                this._schema.itemSchema(this.getSchema(this.type));
            }
            this.parent.operation.addParameter(this.index, this.parameter);
        }
    }
};
JsonParameterStore = __decorate([
    JsonEntityComponent(DecoratorTypes.PARAM),
    __metadata("design:paramtypes", [Object])
], JsonParameterStore);
export { JsonParameterStore };
export const ParamMetadata = JsonParameterStore;
//# sourceMappingURL=JsonParameterStore.js.map