import { Type } from "@tsed/core";
import { JsonEntityStore, JsonEntityStoreOptions } from "./JsonEntityStore";
import type { JsonMethodStore } from "./JsonMethodStore";
import { JsonParameter } from "./JsonParameter";
import { JsonSchema } from "./JsonSchema";
export interface JsonParameterStoreOptions extends JsonEntityStoreOptions {
    dataPath?: string;
    paramType?: string;
    expression?: string;
}
export interface PipeMethods<T = any, R = any> {
    transform(value: T, metadata: JsonParameterStore): R;
}
export declare class JsonParameterStore extends JsonEntityStore {
    paramType: string;
    expression: string;
    dataPath: string;
    /**
     * Define pipes can be called by the framework to transform input parameter
     */
    pipes: Type<PipeMethods>[];
    /**
     * Ref to JsonParameter when the decorated object is a parameter.
     */
    readonly parameter: JsonParameter;
    readonly parent: JsonMethodStore;
    constructor(options: JsonParameterStoreOptions);
    get nestedGenerics(): Type<any>[][];
    set nestedGenerics(nestedGenerics: Type<any>[][]);
    /**
     * Return the required state.
     * @returns {boolean}
     */
    get required(): boolean;
    set required(value: boolean);
    get allowedRequiredValues(): any[];
    static getParams<T extends JsonParameterStore = JsonParameterStore>(target: Type<any>, propertyKey: string | symbol): T[];
    static get(target: Type<any>, propertyKey: string | symbol, index: number): JsonParameterStore;
    /**
     * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
     * @param value
     * @returns {boolean}
     */
    isRequired(value: any): boolean;
    protected getSchema(type: any): JsonSchema;
    protected build(): void;
}
/**
 * @alias JsonParameterStore
 */
export type ParamMetadata = JsonParameterStore;
export declare const ParamMetadata: typeof JsonParameterStore;
