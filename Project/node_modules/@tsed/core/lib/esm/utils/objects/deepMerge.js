import { createInstance } from "./createInstance.js";
import { isFunction } from "./isFunction.js";
import { isPrimitive } from "./isPrimitive.js";
import { isSymbol } from "./isSymbol.js";
import { objectKeys } from "./objectKeys.js";
export function mergeReducerBuilder(cb) {
    return (collection, value, options) => {
        const index = collection.findIndex((item) => cb(item, value));
        if (index === -1) {
            return [...collection, value];
        }
        collection[index] = deepMerge(collection[index], value, options);
        return collection;
    };
}
const defaultReducer = mergeReducerBuilder((a, b) => a === b);
function getReducer({ reducers, parentKey }) {
    if (!reducers) {
        return defaultReducer;
    }
    if (parentKey && reducers[parentKey]) {
        return reducers[parentKey];
    }
    return reducers["default"] || defaultReducer;
}
function shouldReturnObj(obj, source) {
    return isPrimitive(obj) || isSymbol(obj) || isFunction(obj) || source === undefined;
}
function shouldReturnSource(obj, source) {
    return obj === undefined || obj === null || (obj === "" && source !== "");
}
export function deepMerge(source, obj, options = {}) {
    if (shouldReturnSource(obj, source)) {
        return source;
    }
    if (shouldReturnObj(obj, source)) {
        return obj;
    }
    if (Array.isArray(source)) {
        const reducer = getReducer(options);
        return [].concat(obj).reduce((out, value) => reducer(out, value, options), [...source]);
    }
    return [...objectKeys(source), ...objectKeys(obj)].reduce((out, key) => {
        const src = source && source[key];
        const value = deepMerge(src, obj && obj[key], {
            ...options,
            parentKey: key
        });
        if (options.cleanUndefinedProps && value === undefined) {
            return out;
        }
        return {
            ...out,
            [key]: value
        };
    }, createInstance(source));
}
//# sourceMappingURL=deepMerge.js.map