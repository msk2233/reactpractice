"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyToPromise = exports.AnyToPromiseResponseTypes = exports.AnyToPromiseStatus = void 0;
const isObject_1 = require("../utils/objects/isObject");
const isObservable_1 = require("../utils/objects/isObservable");
const isPromise_1 = require("../utils/objects/isPromise");
const isStream_1 = require("../utils/objects/isStream");
/**
 * @ignore
 */
function isResponse(obj) {
    return (0, isObject_1.isObject)(obj) && "data" in obj && "headers" in obj && "status" in obj && "statusText" in obj;
}
/**
 * @ignore
 */
var AnyToPromiseStatus;
(function (AnyToPromiseStatus) {
    AnyToPromiseStatus["PENDING"] = "PENDING";
    AnyToPromiseStatus["CANCELED"] = "CANCELED";
    AnyToPromiseStatus["RESOLVED"] = "RESOLVED";
    AnyToPromiseStatus["REJECTED"] = "REJECTED";
})(AnyToPromiseStatus = exports.AnyToPromiseStatus || (exports.AnyToPromiseStatus = {}));
var AnyToPromiseResponseTypes;
(function (AnyToPromiseResponseTypes) {
    AnyToPromiseResponseTypes["STREAM"] = "STREAM";
    AnyToPromiseResponseTypes["BUFFER"] = "BUFFER";
    AnyToPromiseResponseTypes["DATA"] = "DATA";
})(AnyToPromiseResponseTypes = exports.AnyToPromiseResponseTypes || (exports.AnyToPromiseResponseTypes = {}));
class AnyToPromise {
    status = AnyToPromiseStatus.PENDING;
    args;
    #resolves;
    #rejects;
    #hasNextFunction = false;
    #promise;
    constructor({ hasNextFunction = false } = {}) {
        this.#hasNextFunction = hasNextFunction;
        this.#promise = new Promise((resolve, reject) => {
            this.#resolves = resolve;
            this.#rejects = reject;
        });
    }
    isDone() {
        return this.status !== AnyToPromiseStatus.PENDING;
    }
    get next() {
        this.#hasNextFunction = true;
        return (error) => {
            if (this.isDone()) {
                return;
            }
            return error ? this.reject(error) : this.resolve({ type: AnyToPromiseResponseTypes.DATA });
        };
    }
    /**
     *
     */
    call(cb) {
        if (this.isDone()) {
            return Promise.resolve(this);
        }
        try {
            this.handle(cb());
        }
        catch (er) {
            this.reject(er);
        }
        return this.#promise;
    }
    reject(er) {
        if (this.isDone()) {
            return;
        }
        this.done(AnyToPromiseStatus.REJECTED);
        this.#rejects(er);
    }
    resolve(response = {}) {
        if (this.isDone()) {
            return;
        }
        this.done(AnyToPromiseStatus.RESOLVED);
        this.#resolves({ ...response, state: AnyToPromiseStatus.RESOLVED });
    }
    destroy() { }
    cancel() {
        if (this.isDone()) {
            return;
        }
        this.done(AnyToPromiseStatus.CANCELED);
        return this.#resolves({ state: AnyToPromiseStatus.CANCELED });
    }
    done(status) {
        this.destroy();
        this.status = status;
    }
    handle(process, additionalProps = {}) {
        if (this.isDone()) {
            return;
        }
        if (process) {
            if (this.isCanceledResponse(process)) {
                // ABANDON
                return this.cancel();
            }
            if ((0, isObservable_1.isObservable)(process)) {
                process = process.toPromise();
            }
            if (isResponse(process)) {
                return this.handle(process.data, {
                    ...additionalProps,
                    status: process.status,
                    headers: process.headers
                });
            }
            if ((0, isStream_1.isStream)(process)) {
                return this.resolve({ ...additionalProps, type: AnyToPromiseResponseTypes.STREAM, data: process });
            }
            if ((0, isStream_1.isStream)(process) || Buffer.isBuffer(process)) {
                return this.resolve({ ...additionalProps, type: AnyToPromiseResponseTypes.BUFFER, data: process });
            }
            if ((0, isPromise_1.isPromise)(process)) {
                return process
                    .then((result) => this.handle(result, additionalProps))
                    .catch((error) => {
                    if (error.response && isResponse(error.response)) {
                        return this.handle(error.response);
                    }
                    return this.reject(error);
                });
            }
        }
        if (!this.#hasNextFunction) {
            // no next function and empty response
            return this.resolve({
                ...additionalProps,
                data: process,
                type: AnyToPromiseResponseTypes.DATA
            });
        }
    }
    isCanceledResponse(process) {
        return process === AnyToPromiseStatus.CANCELED;
    }
}
exports.AnyToPromise = AnyToPromise;
//# sourceMappingURL=AnyToPromise.js.map