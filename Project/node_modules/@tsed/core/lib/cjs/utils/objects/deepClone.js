"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepClone = void 0;
const isDate_1 = require("./isDate");
const isFunction_1 = require("./isFunction");
const isNil_1 = require("./isNil");
const isPrimitive_1 = require("./isPrimitive");
const isSymbol_1 = require("./isSymbol");
const isRegExp_1 = require("./isRegExp");
const classOf_1 = require("./classOf");
const isBasicType = (source) => (0, isNil_1.isNil)(source) || (0, isPrimitive_1.isPrimitive)(source) || (0, isSymbol_1.isSymbol)(source) || (0, isFunction_1.isFunction)(source);
/**
 * Return a cloned value
 * @param source
 * @param stack
 */
const deepClone = (source, stack = new WeakMap()) => {
    // provides an early exit for simple cases
    if (isBasicType(source)) {
        return source;
    }
    const stacked = stack.get(source);
    if (stacked) {
        // See issue #1619
        return stacked;
    }
    if (ArrayBuffer.isView(source)) {
        return Buffer.isBuffer(source)
            ? Buffer.from(source)
            : // adds support for all kind of TypedArray such as Int8Array, Uint8Array, etc
                new ((0, classOf_1.classOf)(source))(source.buffer.slice(0), source.byteOffset, source.byteLength);
    }
    if ((0, isDate_1.isDate)(source)) {
        return new Date(source);
    }
    if ((0, isRegExp_1.isRegExp)(source)) {
        return new RegExp(source);
    }
    if (Array.isArray(source)) {
        const clone = [];
        stack.set(source, clone);
        source.forEach((item, idx) => (clone[idx] = (0, exports.deepClone)(item, stack)));
        return clone;
    }
    if (source instanceof Map) {
        const clone = new Map();
        stack.set(source, clone);
        source.forEach((value, key) => clone.set((0, exports.deepClone)(key, stack), (0, exports.deepClone)(value, stack)));
        return clone;
    }
    if (source instanceof Set) {
        const clone = new Set();
        stack.set(source, clone);
        source.forEach((value) => clone.add((0, exports.deepClone)(value, stack)));
        return clone;
    }
    const clone = Object.create(Reflect.getPrototypeOf(source));
    stack.set(source, clone);
    Reflect.ownKeys(source).forEach((key) => {
        // respects property descriptors and the prototype chain more explicitly, which is important for objects with getter/setter.
        const descriptor = Object.getOwnPropertyDescriptor(source, key);
        if (descriptor) {
            if (!(0, isFunction_1.isFunction)(descriptor.value)) {
                Object.defineProperty(clone, key, {
                    ...descriptor,
                    value: (0, exports.deepClone)(descriptor.value, stack)
                });
            }
            else {
                Object.defineProperty(clone, key, descriptor);
            }
        }
    });
    return clone;
};
exports.deepClone = deepClone;
//# sourceMappingURL=deepClone.js.map