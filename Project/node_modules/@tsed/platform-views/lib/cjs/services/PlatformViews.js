"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformViews = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const engines_1 = require("@tsed/engines");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = require("path");
const PlatformViewsSettings_1 = require("../domain/PlatformViewsSettings");
async function patchEJS(ejs) {
    if (!ejs) {
        const mod = await Promise.resolve().then(() => tslib_1.__importStar(require("ejs")));
        ejs = mod.default;
    }
    return {
        compile(str, { client, ...options }) {
            return ejs.compile(str, options);
        }
    };
}
/**
 * @platform
 */
let PlatformViews = class PlatformViews {
    env;
    root;
    cache;
    disabled;
    viewEngine;
    extensionsOptions;
    engineOptions;
    injector;
    #extensions;
    #engines = new Map();
    #cachePaths = new Map();
    async $onInit() {
        if (!this.disabled) {
            this.#extensions = new Map(Object.entries({
                ...PlatformViewsSettings_1.PLATFORM_VIEWS_EXTENSIONS,
                ...this.extensionsOptions
            }));
            await this.loadEngines();
        }
    }
    async loadEngines() {
        engines_1.requires.set("ejs", await patchEJS(engines_1.requires.get("ejs")));
        this.#extensions.forEach((engineType) => {
            if (engines_1.engines.has(engineType)) {
                const options = this.getEngineOptions(engineType);
                if (options.requires) {
                    engines_1.requires.set(engineType, options.requires);
                }
                this.registerEngine(engineType, {
                    options,
                    render: (0, engines_1.getEngine)(engineType)
                });
            }
        });
    }
    getEngines() {
        return [...this.#extensions.entries()].map(([extension, engineType]) => {
            const engine = this.getEngine(this.getExtension(engineType));
            return {
                extension,
                engine
            };
        });
    }
    registerEngine(engineType, engine) {
        this.#engines.set(engineType, engine);
        return this;
    }
    getEngine(type) {
        return this.#engines.get(this.#extensions.get(type) || type);
    }
    getEngineOptions(engineType) {
        return (0, core_1.getValue)(this.engineOptions, engineType, {});
    }
    async render(viewPath, options = {}) {
        const { $ctx } = options;
        options = await this.injector.alterAsync("$alterRenderOptions", options, $ctx);
        const { path, extension } = this.#cachePaths.get(viewPath) || this.#cachePaths.set(viewPath, this.resolve(viewPath)).get(viewPath);
        const engine = this.getEngine(extension);
        if (!engine) {
            throw new Error(`Engine not found to render the following "${viewPath}"`);
        }
        const finalOpts = Object.assign({ cache: this.cache || this.env === core_1.Env.PROD }, engine.options, options, { $ctx });
        return engine.render(path, finalOpts);
    }
    getExtension(viewPath) {
        return ((0, path_1.extname)(viewPath) || this.viewEngine).replace(/\./, "");
    }
    resolve(viewPath) {
        const extension = this.getExtension(viewPath);
        viewPath = viewPath.replace((0, path_1.extname)(viewPath), "") + "." + extension;
        const path = [
            viewPath,
            (0, path_1.resolve)((0, path_1.join)(this.root, viewPath)),
            (0, path_1.resolve)((0, path_1.join)(process.cwd(), "views", viewPath)),
            (0, path_1.resolve)((0, path_1.join)(process.cwd(), "public", viewPath))
        ].find((file) => fs_1.default.existsSync(file)) || viewPath;
        return {
            path,
            extension
        };
    }
};
tslib_1.__decorate([
    (0, di_1.Constant)("env"),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "env", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.root", `${process.cwd()}/views`),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "root", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.cache"),
    tslib_1.__metadata("design:type", Boolean)
], PlatformViews.prototype, "cache", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.disabled", false),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "disabled", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.viewEngine", "ejs"),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "viewEngine", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.extensions", {}),
    tslib_1.__metadata("design:type", Object)
], PlatformViews.prototype, "extensionsOptions", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("views.options", {}),
    tslib_1.__metadata("design:type", Object)
], PlatformViews.prototype, "engineOptions", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformViews.prototype, "injector", void 0);
PlatformViews = tslib_1.__decorate([
    (0, di_1.Module)({
        views: {
            exists: true
        }
    })
], PlatformViews);
exports.PlatformViews = PlatformViews;
//# sourceMappingURL=PlatformViews.js.map