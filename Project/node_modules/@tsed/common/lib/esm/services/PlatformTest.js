import { DITest } from "@tsed/di";
import accepts from "accepts";
import { PlatformBuilder } from "../builder/PlatformBuilder.js";
import { PlatformContext } from "../domain/PlatformContext.js";
import { createInjector } from "../utils/createInjector.js";
import { getConfiguration } from "../utils/getConfiguration.js";
import { PlatformApplication } from "./PlatformApplication.js";
/**
 * @platform
 */
export class PlatformTest extends DITest {
    static adapter;
    static async create(settings = {}) {
        DITest.injector = PlatformTest.createInjector(getConfiguration(settings));
        await DITest.createContainer();
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        return createInjector({
            settings: DITest.configure({ httpPort: false, httpsPort: false, ...settings })
        });
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param listen
     * @param settings
     * @returns {Promise<void>}
     */
    static bootstrap(mod, { listen, ...settings } = {}) {
        return async function before() {
            let instance;
            const adapter = settings.platform || settings.adapter || PlatformTest.adapter;
            /* istanbul ignore next */
            if (!adapter) {
                throw new Error("Platform adapter is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
            }
            // @ts-ignore
            settings = DITest.configure(settings);
            settings.adapter = adapter;
            const configuration = getConfiguration(settings, mod);
            const disableComponentsScan = configuration.disableComponentsScan || !!process.env.WEBPACK;
            if (!disableComponentsScan) {
                const { importProviders } = await import("@tsed/components-scan");
                await importProviders(configuration);
            }
            instance = await PlatformBuilder.build(mod, configuration).bootstrap();
            await instance.listen(!!listen);
            // used by inject method
            DITest.injector = instance.injector;
        };
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return async () => {
            if (!DITest.hasInjector()) {
                await PlatformTest.create();
            }
            const injector = DITest.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
            }
            return func(...deps);
        };
    }
    /**
     * Return the raw application (express or koa).
     * Use this callback with SuperTest.
     *
     * ```typescript
     * let request: SuperTest.Agent;
     * beforeEach(PlatformTest.bootstrap(Server, {
     *   mount: {
     *     "/rest": [ProductsController]
     *   }
     * }));
     * beforeEach(() => {
     *   request = SuperTest(PlatformTest.callback());
     * });
     * ```
     */
    static callback() {
        return DITest.injector.get(PlatformApplication)?.callback();
    }
    static createRequest(options = {}) {
        return {
            headers: {},
            method: "GET",
            url: "/",
            query: {},
            get(key) {
                return this.headers[key.toLowerCase()];
            },
            accepts(mime) {
                return accepts(this).types([].concat(mime));
            },
            ...options
        };
    }
    static createResponse(options = {}) {
        return {
            headers: {},
            locals: {},
            statusCode: 200,
            status(code) {
                this.statusCode = code;
                return this;
            },
            contentType(content) {
                this.set("content-type", content);
            },
            contentLength(content) {
                this.set("content-length", content);
            },
            redirect(status, path) {
                this.statusCode = status;
                this.set("location", path);
            },
            location(path) {
                this.set("location", path);
            },
            get(key) {
                return this.headers[key.toLowerCase()];
            },
            getHeaders() {
                return this.headers;
            },
            set(key, value) {
                this.headers[key.toLowerCase()] = value;
                return this;
            },
            setHeader(key, value) {
                this.headers[key.toLowerCase()] = value;
                return this;
            },
            send(data) {
                this.data = data;
            },
            json(data) {
                this.data = data;
            },
            end(data) {
                this.data = data;
            },
            ...options
        };
    }
    static createRequestContext(options = {}) {
        const event = {
            ...options.event,
            request: options?.request?.request || options?.event?.request || PlatformTest.createRequest(),
            response: options?.response?.response || options?.event?.response || PlatformTest.createResponse()
        };
        const $ctx = new PlatformContext({
            id: "id",
            injector: DITest.injector,
            logger: DITest.injector.logger,
            url: "/",
            ...options,
            event
        });
        if (options.endpoint) {
            $ctx.endpoint = options.endpoint;
        }
        return $ctx;
    }
}
//# sourceMappingURL=PlatformTest.js.map