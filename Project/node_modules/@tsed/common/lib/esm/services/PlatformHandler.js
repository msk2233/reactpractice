import { __decorate, __metadata } from "tslib";
import { AnyToPromiseStatus, catchAsyncError } from "@tsed/core";
import { Inject, Injectable, ProviderScope } from "@tsed/di";
import { PlatformExceptions } from "@tsed/platform-exceptions";
import { PlatformParams } from "@tsed/platform-params";
import { PlatformResponseFilter } from "@tsed/platform-response-filter";
import { PlatformHandlerMetadata, PlatformHandlerType, PlatformRouters, useResponseHandler } from "@tsed/platform-router";
import { AnyToPromiseWithCtx } from "../domain/AnyToPromiseWithCtx.js";
import { setResponseHeaders } from "../utils/setResponseHeaders.js";
import { PlatformApplication } from "./PlatformApplication.js";
import { PlatformMiddlewaresChain } from "./PlatformMiddlewaresChain.js";
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    platformRouters;
    responseFilter;
    platformParams;
    platformExceptions;
    platformApplication;
    platformMiddlewaresChain;
    constructor(platformRouters) {
        this.platformRouters = platformRouters;
        // configure the router module
        platformRouters.hooks
            .on("alterEndpointHandlers", (handlers, operationRoute) => {
            handlers = this.platformMiddlewaresChain.get(handlers, operationRoute);
            handlers.after.push(useResponseHandler(this.flush.bind(this)));
            return handlers;
        })
            .on("alterHandler", (handlerMetadata) => {
            const handler = handlerMetadata.isInjectable() ? this.createHandler(handlerMetadata) : handlerMetadata.handler;
            return this.platformApplication.adapter.mapHandler(handler, handlerMetadata);
        });
    }
    createHandler(handlerMetadata) {
        const handler = this.platformParams.compileHandler(handlerMetadata);
        return ($ctx) => {
            $ctx.handlerMetadata = handlerMetadata;
            return this.onRequest(handler, $ctx);
        };
    }
    /**
     * @param provider
     * @param propertyKey
     */
    createCustomHandler(provider, propertyKey) {
        const metadata = new PlatformHandlerMetadata({
            provider,
            type: PlatformHandlerType.CUSTOM,
            propertyKey
        });
        return this.createHandler(metadata);
    }
    /**
     * Call handler when a request his handle
     */
    async onRequest(handler, $ctx) {
        const { handlerMetadata } = $ctx;
        if (handlerMetadata.type === PlatformHandlerType.CTX_FN) {
            return handler({ $ctx });
        }
        const resolver = new AnyToPromiseWithCtx($ctx);
        const response = await resolver.call(handler);
        // Note: restore previous handler metadata (for OIDC)
        $ctx.handlerMetadata = handlerMetadata;
        if (response.state === AnyToPromiseStatus.RESOLVED && !$ctx.isDone()) {
            return this.onResponse(response, $ctx);
        }
    }
    onResponse({ status, data, headers }, $ctx) {
        if (status) {
            $ctx.response.status(status);
        }
        if (headers) {
            $ctx.response.setHeaders(headers);
        }
        if (data !== undefined) {
            $ctx.data = data;
        }
        $ctx.error = null;
        // set headers each times that an endpoint is called
        if ($ctx.handlerMetadata.isEndpoint()) {
            setResponseHeaders($ctx);
        }
    }
    /**
     * Send the response to the consumer.
     * @protected
     * @param $ctx
     */
    async flush($ctx) {
        if (!$ctx.error) {
            $ctx.error = await catchAsyncError(async () => {
                const { response } = $ctx;
                if (!$ctx.isDone()) {
                    let data = await this.responseFilter.serialize($ctx.data, $ctx);
                    data = await this.responseFilter.transform(data, $ctx);
                    response.body(data);
                }
            });
        }
        if ($ctx.error) {
            this.platformExceptions.catch($ctx.error, $ctx);
        }
    }
};
__decorate([
    Inject(),
    __metadata("design:type", PlatformResponseFilter)
], PlatformHandler.prototype, "responseFilter", void 0);
__decorate([
    Inject(),
    __metadata("design:type", PlatformParams)
], PlatformHandler.prototype, "platformParams", void 0);
__decorate([
    Inject(),
    __metadata("design:type", PlatformExceptions)
], PlatformHandler.prototype, "platformExceptions", void 0);
__decorate([
    Inject(),
    __metadata("design:type", PlatformApplication)
], PlatformHandler.prototype, "platformApplication", void 0);
__decorate([
    Inject(),
    __metadata("design:type", PlatformMiddlewaresChain)
], PlatformHandler.prototype, "platformMiddlewaresChain", void 0);
PlatformHandler = __decorate([
    Injectable({
        scope: ProviderScope.SINGLETON
    }),
    __metadata("design:paramtypes", [PlatformRouters])
], PlatformHandler);
export { PlatformHandler };
//# sourceMappingURL=PlatformHandler.js.map