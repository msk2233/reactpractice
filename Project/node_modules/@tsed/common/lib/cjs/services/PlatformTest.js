"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformTest = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const accepts_1 = tslib_1.__importDefault(require("accepts"));
const PlatformBuilder_1 = require("../builder/PlatformBuilder");
const PlatformContext_1 = require("../domain/PlatformContext");
const createInjector_1 = require("../utils/createInjector");
const getConfiguration_1 = require("../utils/getConfiguration");
const PlatformApplication_1 = require("./PlatformApplication");
/**
 * @platform
 */
class PlatformTest extends di_1.DITest {
    static adapter;
    static async create(settings = {}) {
        di_1.DITest.injector = PlatformTest.createInjector((0, getConfiguration_1.getConfiguration)(settings));
        await di_1.DITest.createContainer();
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        return (0, createInjector_1.createInjector)({
            settings: di_1.DITest.configure({ httpPort: false, httpsPort: false, ...settings })
        });
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param listen
     * @param settings
     * @returns {Promise<void>}
     */
    static bootstrap(mod, { listen, ...settings } = {}) {
        return async function before() {
            let instance;
            const adapter = settings.platform || settings.adapter || PlatformTest.adapter;
            /* istanbul ignore next */
            if (!adapter) {
                throw new Error("Platform adapter is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
            }
            // @ts-ignore
            settings = di_1.DITest.configure(settings);
            settings.adapter = adapter;
            const configuration = (0, getConfiguration_1.getConfiguration)(settings, mod);
            const disableComponentsScan = configuration.disableComponentsScan || !!process.env.WEBPACK;
            if (!disableComponentsScan) {
                const { importProviders } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/components-scan")));
                await importProviders(configuration);
            }
            instance = await PlatformBuilder_1.PlatformBuilder.build(mod, configuration).bootstrap();
            await instance.listen(!!listen);
            // used by inject method
            di_1.DITest.injector = instance.injector;
        };
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return async () => {
            if (!di_1.DITest.hasInjector()) {
                await PlatformTest.create();
            }
            const injector = di_1.DITest.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
            }
            return func(...deps);
        };
    }
    /**
     * Return the raw application (express or koa).
     * Use this callback with SuperTest.
     *
     * ```typescript
     * let request: SuperTest.Agent;
     * beforeEach(PlatformTest.bootstrap(Server, {
     *   mount: {
     *     "/rest": [ProductsController]
     *   }
     * }));
     * beforeEach(() => {
     *   request = SuperTest(PlatformTest.callback());
     * });
     * ```
     */
    static callback() {
        return di_1.DITest.injector.get(PlatformApplication_1.PlatformApplication)?.callback();
    }
    static createRequest(options = {}) {
        return {
            headers: {},
            method: "GET",
            url: "/",
            query: {},
            get(key) {
                return this.headers[key.toLowerCase()];
            },
            accepts(mime) {
                return (0, accepts_1.default)(this).types([].concat(mime));
            },
            ...options
        };
    }
    static createResponse(options = {}) {
        return {
            headers: {},
            locals: {},
            statusCode: 200,
            status(code) {
                this.statusCode = code;
                return this;
            },
            contentType(content) {
                this.set("content-type", content);
            },
            contentLength(content) {
                this.set("content-length", content);
            },
            redirect(status, path) {
                this.statusCode = status;
                this.set("location", path);
            },
            location(path) {
                this.set("location", path);
            },
            get(key) {
                return this.headers[key.toLowerCase()];
            },
            getHeaders() {
                return this.headers;
            },
            set(key, value) {
                this.headers[key.toLowerCase()] = value;
                return this;
            },
            setHeader(key, value) {
                this.headers[key.toLowerCase()] = value;
                return this;
            },
            send(data) {
                this.data = data;
            },
            json(data) {
                this.data = data;
            },
            end(data) {
                this.data = data;
            },
            ...options
        };
    }
    static createRequestContext(options = {}) {
        const event = {
            ...options.event,
            request: options?.request?.request || options?.event?.request || PlatformTest.createRequest(),
            response: options?.response?.response || options?.event?.response || PlatformTest.createResponse()
        };
        const $ctx = new PlatformContext_1.PlatformContext({
            id: "id",
            injector: di_1.DITest.injector,
            logger: di_1.DITest.injector.logger,
            url: "/",
            ...options,
            event
        });
        if (options.endpoint) {
            $ctx.endpoint = options.endpoint;
        }
        return $ctx;
    }
}
exports.PlatformTest = PlatformTest;
//# sourceMappingURL=PlatformTest.js.map