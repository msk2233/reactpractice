"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformHandler = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const platform_exceptions_1 = require("@tsed/platform-exceptions");
const platform_params_1 = require("@tsed/platform-params");
const platform_response_filter_1 = require("@tsed/platform-response-filter");
const platform_router_1 = require("@tsed/platform-router");
const AnyToPromiseWithCtx_1 = require("../domain/AnyToPromiseWithCtx");
const setResponseHeaders_1 = require("../utils/setResponseHeaders");
const PlatformApplication_1 = require("./PlatformApplication");
const PlatformMiddlewaresChain_1 = require("./PlatformMiddlewaresChain");
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    platformRouters;
    responseFilter;
    platformParams;
    platformExceptions;
    platformApplication;
    platformMiddlewaresChain;
    constructor(platformRouters) {
        this.platformRouters = platformRouters;
        // configure the router module
        platformRouters.hooks
            .on("alterEndpointHandlers", (handlers, operationRoute) => {
            handlers = this.platformMiddlewaresChain.get(handlers, operationRoute);
            handlers.after.push((0, platform_router_1.useResponseHandler)(this.flush.bind(this)));
            return handlers;
        })
            .on("alterHandler", (handlerMetadata) => {
            const handler = handlerMetadata.isInjectable() ? this.createHandler(handlerMetadata) : handlerMetadata.handler;
            return this.platformApplication.adapter.mapHandler(handler, handlerMetadata);
        });
    }
    createHandler(handlerMetadata) {
        const handler = this.platformParams.compileHandler(handlerMetadata);
        return ($ctx) => {
            $ctx.handlerMetadata = handlerMetadata;
            return this.onRequest(handler, $ctx);
        };
    }
    /**
     * @param provider
     * @param propertyKey
     */
    createCustomHandler(provider, propertyKey) {
        const metadata = new platform_router_1.PlatformHandlerMetadata({
            provider,
            type: platform_router_1.PlatformHandlerType.CUSTOM,
            propertyKey
        });
        return this.createHandler(metadata);
    }
    /**
     * Call handler when a request his handle
     */
    async onRequest(handler, $ctx) {
        const { handlerMetadata } = $ctx;
        if (handlerMetadata.type === platform_router_1.PlatformHandlerType.CTX_FN) {
            return handler({ $ctx });
        }
        const resolver = new AnyToPromiseWithCtx_1.AnyToPromiseWithCtx($ctx);
        const response = await resolver.call(handler);
        // Note: restore previous handler metadata (for OIDC)
        $ctx.handlerMetadata = handlerMetadata;
        if (response.state === core_1.AnyToPromiseStatus.RESOLVED && !$ctx.isDone()) {
            return this.onResponse(response, $ctx);
        }
    }
    onResponse({ status, data, headers }, $ctx) {
        if (status) {
            $ctx.response.status(status);
        }
        if (headers) {
            $ctx.response.setHeaders(headers);
        }
        if (data !== undefined) {
            $ctx.data = data;
        }
        $ctx.error = null;
        // set headers each times that an endpoint is called
        if ($ctx.handlerMetadata.isEndpoint()) {
            (0, setResponseHeaders_1.setResponseHeaders)($ctx);
        }
    }
    /**
     * Send the response to the consumer.
     * @protected
     * @param $ctx
     */
    async flush($ctx) {
        if (!$ctx.error) {
            $ctx.error = await (0, core_1.catchAsyncError)(async () => {
                const { response } = $ctx;
                if (!$ctx.isDone()) {
                    let data = await this.responseFilter.serialize($ctx.data, $ctx);
                    data = await this.responseFilter.transform(data, $ctx);
                    response.body(data);
                }
            });
        }
        if ($ctx.error) {
            this.platformExceptions.catch($ctx.error, $ctx);
        }
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_response_filter_1.PlatformResponseFilter)
], PlatformHandler.prototype, "responseFilter", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_params_1.PlatformParams)
], PlatformHandler.prototype, "platformParams", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", platform_exceptions_1.PlatformExceptions)
], PlatformHandler.prototype, "platformExceptions", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformApplication_1.PlatformApplication)
], PlatformHandler.prototype, "platformApplication", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformMiddlewaresChain_1.PlatformMiddlewaresChain)
], PlatformHandler.prototype, "platformMiddlewaresChain", void 0);
PlatformHandler = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [platform_router_1.PlatformRouters])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map