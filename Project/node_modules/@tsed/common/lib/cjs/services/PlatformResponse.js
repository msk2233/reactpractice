"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformResponse = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const encodeurl_1 = tslib_1.__importDefault(require("encodeurl"));
/**
 * Platform Response abstraction layer.
 * @platform
 */
let PlatformResponse = class PlatformResponse {
    $ctx;
    data;
    constructor($ctx) {
        this.$ctx = $ctx;
    }
    /**
     * The current @@PlatformRequest@@.
     */
    get request() {
        return this.$ctx.request;
    }
    get raw() {
        return this.$ctx.event.response;
    }
    /**
     * Get the current statusCode
     */
    get statusCode() {
        return this.raw.statusCode;
    }
    /**
     * An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to app.locals.
     *
     * This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.
     */
    get locals() {
        return this.raw.locals;
    }
    /**
     * Return the original response framework instance
     */
    get response() {
        return this.getResponse();
    }
    /**
     * Return the original response node.js instance
     */
    get res() {
        return this.getRes();
    }
    /**
     * Returns the HTTP response header specified by field. The match is case-insensitive.
     *
     * ```typescript
     * response.get('Content-Type') // => "text/plain"
     * ```
     *
     * @param name
     */
    get(name) {
        return this.raw.get(name);
    }
    getHeaders() {
        return this.raw.getHeaders();
    }
    /**
     * Return the Framework response object (express, koa, etc...)
     */
    getResponse() {
        return this.raw;
    }
    /**
     * Return the Node.js response object
     */
    getRes() {
        return this.raw;
    }
    hasStatus() {
        return this.statusCode !== 200;
    }
    /**
     * Sets the HTTP status for the response.
     *
     * @param status
     */
    status(status) {
        this.raw.status(status);
        return this;
    }
    /**
     * Set header `field` to `val`, or pass
     * an object of header fields.
     *
     * Examples:
     * ```typescript
     * response.setHeaders({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
     * ```
     *
     * Aliased as `res.header()`.
     */
    setHeaders(headers) {
        // apply headers
        Object.entries(headers).forEach(([key, item]) => {
            this.setHeader(key, item);
        });
        return this;
    }
    setHeader(key, item) {
        this.raw.set(key, this.formatHeader(key, item));
        return this;
    }
    /**
     * Set `Content-Type` response header with `type` through `mime.lookup()`
     * when it does not contain "/", or set the Content-Type to `type` otherwise.
     *
     * Examples:
     *
     *     res.type('.html');
     *     res.type('html');
     *     res.type('json');
     *     res.type('application/json');
     *     res.type('png');
     */
    contentType(contentType) {
        this.raw.contentType(contentType);
        return this;
    }
    contentLength(length) {
        this.setHeader("Content-Length", length);
        return this;
    }
    getContentLength() {
        if (this.get("Content-Length")) {
            return parseInt(this.get("Content-Length"), 10) || 0;
        }
    }
    getContentType() {
        return (this.get("Content-Type") || "").split(";")[0];
    }
    /**
     * Sets the HTTP response Content-Disposition header field to “attachment”.
     * If a filename is given, then it sets the Content-Type based on the extension name via res.type(), and sets the Content-Disposition “filename=” parameter.
     *
     * ```typescript
     * res.attachment()
     * // Content-Disposition: attachment
     *
     * res.attachment('path/to/logo.png')
     * // Content-Disposition: attachment; filename="logo.png"
     * // Content-Type: image/png
     * ```
     *
     * @param filename
     */
    attachment(filename) {
        this.raw.attachment(filename);
        return this;
    }
    /**
     * Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an [HTTP status code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
     * If not specified, status defaults to `302 Found`.
     *
     * @param status
     * @param url
     */
    redirect(status, url) {
        status = status || 302;
        this.location(url);
        // Set location header
        url = this.get("Location");
        const txt = `${(0, schema_1.getStatusMessage)(status)}. Redirecting to ${url}`;
        this.status(status);
        if (this.request.method === "HEAD") {
            this.end();
        }
        else {
            this.setHeader("Content-Length", Buffer.byteLength(txt)).end(txt);
        }
        return this;
    }
    /**
     * Sets the response Location HTTP header to the specified path parameter.
     *
     * @param location
     */
    location(location) {
        this.setHeader("Location", location);
        return this;
    }
    /**
     * Stream the given data.
     *
     * @param data
     */
    stream(data) {
        data.pipe(this.raw);
        return this;
    }
    /**
     * Renders a view and sends the rendered HTML string to the client.
     *
     * @param path
     * @param options
     */
    async render(path, options = {}) {
        const { PlatformViews } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/platform-views")));
        const platformViews = await this.$ctx.injector.lazyInvoke(PlatformViews);
        return platformViews.render(path, {
            ...this.locals,
            ...options
        });
    }
    /**
     * Send any data to your consumer.
     *
     * This method accept a ReadableStream, a plain object, boolean, string, number, null and undefined data.
     * It chooses the better way to send the data.
     *
     * @param data
     */
    body(data) {
        this.data = data;
        if (data === undefined) {
            this.end();
            return this;
        }
        if ((0, core_1.isStream)(data)) {
            this.stream(data);
            return this;
        }
        if (Buffer.isBuffer(data)) {
            this.buffer(data);
            return this;
        }
        if ((0, core_1.isBoolean)(data) || (0, core_1.isNumber)(data) || (0, core_1.isString)(data) || data === null) {
            this.end(data);
            return this;
        }
        this.json(data);
        return this;
    }
    getBody() {
        return this.data;
    }
    /**
     * Add a listener to handler the end of the request/response.
     * @param cb
     */
    onEnd(cb) {
        const res = this.getRes();
        res.on("finish", cb);
        return this;
    }
    isDone() {
        if (this.$ctx.isFinished()) {
            return true;
        }
        const res = this.getRes();
        return Boolean(this.isHeadersSent() || res.writableEnded || res.writableFinished);
    }
    isHeadersSent() {
        return this.getRes().headersSent;
    }
    cookie(name, value, opts) {
        if (value === null) {
            this.raw.clearCookie(name);
            return this;
        }
        this.raw.cookie(name, value, opts);
        const cookie = this.raw.get("set-cookie");
        if (!(0, core_1.isArray)(value)) {
            this.raw.set("set-cookie", [].concat(cookie));
        }
        return this;
    }
    formatHeader(key, item) {
        if (key.toLowerCase() === "location") {
            // "back" is an alias for the referrer
            if (item === "back") {
                item = this.request.get("Referrer") || "/";
            }
            item = (0, encodeurl_1.default)(String(item));
        }
        return item;
    }
    json(data) {
        this.raw.json(data);
        return this;
    }
    buffer(data) {
        if (!this.getContentType()) {
            this.contentType("application/octet-stream");
        }
        this.contentLength(data.length);
        this.end(data);
    }
    end(data) {
        // data = await this.$ctx.injector.alter("$onResponse", data, this.$ctx);
        this.raw.send(data);
    }
};
PlatformResponse = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    (0, di_1.Scope)(di_1.ProviderScope.INSTANCE),
    tslib_1.__metadata("design:paramtypes", [Function])
], PlatformResponse);
exports.PlatformResponse = PlatformResponse;
//# sourceMappingURL=PlatformResponse.js.map