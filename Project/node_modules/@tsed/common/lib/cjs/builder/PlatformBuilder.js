"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformBuilder = void 0;
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const platform_middlewares_1 = require("@tsed/platform-middlewares");
const Platform_1 = require("../services/Platform");
const PlatformAdapter_1 = require("../services/PlatformAdapter");
const PlatformApplication_1 = require("../services/PlatformApplication");
const closeServer_1 = require("../utils/closeServer");
const createInjector_1 = require("../utils/createInjector");
const getConfiguration_1 = require("../utils/getConfiguration");
const getStaticsOptions_1 = require("../utils/getStaticsOptions");
const printRoutes_1 = require("../utils/printRoutes");
/**
 * @platform
 */
class PlatformBuilder {
    static adapter;
    name = "";
    startedAt = new Date();
    current = new Date();
    #injector;
    #rootModule;
    #adapter;
    #promise;
    #servers;
    #listeners = [];
    constructor(adapter, module, settings) {
        this.#rootModule = module;
        const configuration = (0, getConfiguration_1.getConfiguration)(settings, module);
        const adapterKlass = adapter || PlatformBuilder.adapter;
        configuration.PLATFORM_NAME = adapterKlass.NAME;
        this.name = adapterKlass.NAME;
        this.#injector = (0, createInjector_1.createInjector)({
            adapter: adapterKlass,
            settings: configuration
        });
        this.log(`Loading ${adapterKlass.NAME.toUpperCase()} platform adapter...`);
        this.#adapter = this.#injector.get(PlatformAdapter_1.PlatformAdapter);
        this.createHttpServers();
        this.log("Injector created...");
    }
    get injector() {
        return this.#injector;
    }
    get rootModule() {
        return this.#injector.get(this.#rootModule);
    }
    get app() {
        return this.injector.get(PlatformApplication_1.PlatformApplication);
    }
    get platform() {
        return this.injector.get(Platform_1.Platform);
    }
    get adapter() {
        return this.#adapter;
    }
    /**
     * Return the settings configured by the decorator @@Configuration@@.
     *
     * ```typescript
     * @Configuration({
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {PlatformConfiguration}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    get disableBootstrapLog() {
        return this.settings.get("logger.disableBootstrapLog");
    }
    static create(module, settings) {
        return this.build(module, {
            httpsPort: false,
            httpPort: false,
            ...settings
        });
    }
    static build(module, { adapter, ...settings }) {
        return new PlatformBuilder(adapter, module, settings);
    }
    /**
     * Bootstrap a server application
     * @param module
     * @param settings
     */
    static bootstrap(module, settings) {
        return this.build(module, settings).bootstrap();
    }
    callback(...args) {
        return this.adapter.app.callback(...args);
    }
    log(...data) {
        return !this.disableBootstrapLog && this.logger.info(...data, this.diff());
    }
    /**
     * Add classes to the components list
     * @param classes
     */
    addComponents(classes) {
        this.settings.set("imports", this.settings.get("imports", []).concat(classes));
        return this;
    }
    /**
     * Add classes decorated by @@Controller@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * platform.addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     */
    addControllers(endpoint, controllers) {
        [].concat(controllers).forEach((token) => {
            this.settings.routes.push({ token, route: endpoint });
        });
    }
    async runLifecycle() {
        // init adapter (Express, Koa, etc...)
        await this.#adapter.onInit();
        (0, di_1.setLoggerConfiguration)(this.injector);
        // create the middleware mapping to be executed to the expected hook
        await this.mapTokenMiddlewares();
        await this.loadInjector();
        // add the context middleware to the application
        this.log("Mount app context");
        this.#adapter.useContext();
        // init routes (controllers, middlewares, etc...)
        this.log("Load routes");
        await this.#adapter.beforeLoadRoutes();
        // istanbul ignore next
        if (this.settings.get("logger.level") !== "off") {
            const { PlatformLogMiddleware } = await Promise.resolve().then(() => __importStar(require("@tsed/platform-log-middleware")));
            this.app.use(PlatformLogMiddleware);
        }
        if (this.rootModule.$beforeRoutesInit) {
            await this.rootModule.$beforeRoutesInit();
            // remove method to avoid multiple call and preserve hook order
            this.rootModule.$beforeRoutesInit = () => { };
        }
        // Hooks execution (adding middlewares, controllers, services, etc...)
        await this.loadStatics("$beforeRoutesInit");
        await this.callHook("$beforeRoutesInit");
        const routes = this.injector.settings.get("routes");
        this.platform.addRoutes(routes);
        await this.callHook("$onRoutesInit");
        await this.loadStatics("$afterRoutesInit");
        await this.callHook("$afterRoutesInit");
        await this.#adapter.afterLoadRoutes();
        // map routers are loaded after all hooks because it contains all added middlewares/controllers in the virtual Ts.ED layers
        // This step will convert all Ts.ED layers to the platform layer (Express or Koa)
        await this.mapRouters();
        // Server is bootstrapped and ready to listen
        return this;
    }
    async loadInjector() {
        const { injector } = this;
        this.log("Build providers");
        await injector.loadModule(this.#rootModule);
        this.log("Settings and injector loaded...");
        await this.callHook("$afterInit");
    }
    async listen(network = true) {
        if (!this.#promise) {
            await this.bootstrap();
        }
        await this.callHook("$beforeListen");
        if (network) {
            await this.listenServers();
        }
        await this.callHook("$afterListen");
        await this.ready();
    }
    async stop() {
        await this.callHook("$onDestroy");
        await this.injector.destroy();
        this.#listeners.map(closeServer_1.closeServer);
    }
    async ready() {
        const { startedAt } = this;
        await this.callHook("$onReady");
        await this.injector.emit("$onServerReady");
        this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
    }
    async callHook(hook, ...args) {
        const { injector } = this;
        if (!this.disableBootstrapLog) {
            injector.logger.debug(`\x1B[1mCall hook ${hook}\x1B[22m`);
        }
        // Load middlewares for the given hook
        this.loadMiddlewaresFor(hook);
        // call hooks added by providers
        await injector.emit(hook, ...args);
    }
    loadStatics(hook) {
        const statics = this.settings.get("statics");
        (0, getStaticsOptions_1.getStaticsOptions)(statics).forEach(({ path, options }) => {
            if (options.hook === hook) {
                this.platform.app.statics(path, options);
            }
        });
    }
    useProvider(token, settings) {
        this.injector.addProvider(token, settings);
        return this;
    }
    bootstrap() {
        this.#promise = this.#promise || this.runLifecycle();
        return this.#promise;
    }
    mapRouters() {
        const layers = this.platform.getLayers();
        this.#adapter.mapLayers(layers);
        const rawBody = this.settings.get("rawBody") ||
            layers.some(({ handlers }) => {
                return handlers.some((handler) => handler.opts?.paramsTypes?.RAW_BODY);
            });
        this.settings.set("rawBody", rawBody);
        return this.logRoutes(layers.filter((layer) => layer.isProvider()));
    }
    diff() {
        const ms = di_1.colors.yellow(`+${new Date().getTime() - this.current.getTime()}ms`);
        this.current = new Date();
        return ms;
    }
    /**
     * Load middlewares from configuration for the given hook
     * @param hook
     * @protected
     */
    loadMiddlewaresFor(hook) {
        return (0, platform_middlewares_1.getMiddlewaresForHook)(hook, this.settings, "$beforeRoutesInit").forEach(({ use }) => {
            this.app.use(use);
        });
    }
    createHttpServers() {
        this.#servers = this.#adapter.getServers();
    }
    async listenServers() {
        this.#listeners = await Promise.all(this.#servers.map((cb) => cb && cb()));
    }
    async logRoutes(layers) {
        const { logger } = this;
        this.log("Routes mounted...");
        if (!this.settings.get("logger.disableRoutesSummary") && !this.disableBootstrapLog) {
            const routes = layers.map((layer) => {
                return {
                    url: layer.path,
                    method: layer.method,
                    name: layer.opts.name || `${layer.provider.className}.constructor()`,
                    className: layer.opts.className || layer.provider.className,
                    methodClassName: layer.opts.methodClassName || ""
                };
            });
            logger.info((0, printRoutes_1.printRoutes)(await this.injector.alterAsync("$logRoutes", routes)));
        }
    }
    async mapTokenMiddlewares() {
        let middlewares = this.injector.settings.get("middlewares", []);
        const { env } = this.injector.settings;
        const defaultHook = "$beforeRoutesInit";
        const promises = middlewares.map(async (middleware) => {
            var _a;
            if ((0, core_1.isFunction)(middleware)) {
                return {
                    env,
                    hook: defaultHook,
                    use: middleware
                };
            }
            if ((0, core_1.isString)(middleware)) {
                middleware = { env, use: middleware, hook: defaultHook };
            }
            let { use, options } = middleware;
            if ((0, core_1.isString)(use)) {
                if (["text-parser", "raw-parser", "json-parser", "urlencoded-parser"].includes(use)) {
                    use = this.adapter.bodyParser(use.replace("-parser", ""), options);
                }
                else {
                    const mod = await (_a = use, Promise.resolve().then(() => __importStar(require(_a))));
                    use = (mod.default || mod)(options);
                }
            }
            if ((0, core_1.isClass)(use) && ["$beforeInit", "$onInit", "$afterInit"].includes(middleware.hook)) {
                throw new Error(`Ts.ED Middleware "${(0, core_1.nameOf)(use)}" middleware cannot be added on ${middleware.hook} hook. Use one of this hooks instead: $beforeRoutesInit, $onRoutesInit, $afterRoutesInit, $beforeListen, $afterListen, $onReady`);
            }
            return {
                env,
                hook: defaultHook,
                ...middleware,
                use
            };
        });
        middlewares = await Promise.all(promises);
        this.injector.settings.set("middlewares", middlewares.filter((middleware) => middleware.use));
    }
}
exports.PlatformBuilder = PlatformBuilder;
//# sourceMappingURL=PlatformBuilder.js.map