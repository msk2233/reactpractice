"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPException = exports.Exception = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const change_case_1 = require("change-case");
const statuses_1 = tslib_1.__importDefault(require("statuses"));
class Exception extends Error {
    /**
     * Exception base name
     * @type {string}
     */
    name = "HTTP_EXCEPTION";
    /**
     * Message of the exception
     */
    message;
    /**
     * Exception type
     * @type {string}
     */
    type = "HTTP_EXCEPTION";
    /**
     * Stack calling
     */
    stack;
    origin;
    /**
     * HTTP Code Status
     */
    status;
    /**
     *
     */
    body;
    /**
     * Headers must be sent to the response
     */
    headers = {};
    static validate(status, family) {
        if (status < 100 || status >= 600) {
            throw new Error("Status must be between 100 and 599");
        }
        if (status.toString()[0] !== family.charAt(0)) {
            throw new Error(`Status ${status} does not belong to the family ${family}`);
        }
        return status;
    }
    constructor(status = 500, message = "", origin) {
        super(message);
        this.status = status;
        this.message = message;
        this.name = this.#getStatusConstant();
        this.setOrigin(origin);
        Error.captureStackTrace(this);
    }
    setHeaders(headers) {
        this.headers = {
            ...this.headers,
            ...headers
        };
        return this;
    }
    setHeader(key, value) {
        this.headers[key] = value;
        return this;
    }
    setOrigin(origin) {
        if (origin) {
            if (origin instanceof Error) {
                this.origin = origin;
                this.message = `${this.message}, innerException: ${this.origin.message}`.trim();
            }
            else if (typeof origin === "string") {
                this.origin = new Error(origin);
                this.message = `${this.message}, innerException: ${this.origin.message}`.trim();
            }
            else {
                this.body = origin;
            }
        }
    }
    toString() {
        return `${this.name}(${this.status}): ${this.message} `.trim();
    }
    #getStatusConstant() {
        try {
            return this.status === 200 ? "SUCCESS" : (0, change_case_1.constantCase)(String((0, statuses_1.default)(this.status)));
        }
        catch (er) {
            return (0, change_case_1.constantCase)((0, core_1.nameOf)((0, core_1.classOf)(this)));
        }
    }
}
exports.Exception = Exception;
class HTTPException extends Exception {
}
exports.HTTPException = HTTPException;
//# sourceMappingURL=Exception.js.map