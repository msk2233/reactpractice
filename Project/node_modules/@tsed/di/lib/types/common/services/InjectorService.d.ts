import { Container } from "../domain/Container";
import { LocalsContainer } from "../domain/LocalsContainer";
import { Provider } from "../domain/Provider";
import { ProviderScope } from "../domain/ProviderScope";
import { DILogger } from "../interfaces/DILogger";
import { InjectablePropertyOptions, InjectablePropertyValue } from "../interfaces/InjectableProperties";
import { InvokeOptions } from "../interfaces/InvokeOptions";
import { TokenProvider } from "../interfaces/TokenProvider";
import { DIConfiguration } from "./DIConfiguration";
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/di";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services are imported, you can load InjectorService.
 * const injector = new InjectorService()
 *
 * await injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 */
export declare class InjectorService extends Container {
    #private;
    settings: DIConfiguration;
    logger: DILogger;
    private resolvedConfiguration;
    constructor();
    get resolvers(): import("..").DIResolver[];
    get scopes(): Record<string, ProviderScope>;
    /**
     * Retrieve default scope for a given provider.
     * @param provider
     */
    scopeOf(provider: Provider): ProviderScope;
    /**
     * Return a list of instance build by the injector.
     */
    toArray(): any[];
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param token The class or symbol registered in InjectorService.
     * @param options
     * @returns {boolean}
     */
    get<T = any>(token: TokenProvider<T>, options?: any): T | undefined;
    /**
     * Return all instance of the same provider type
     * @param type
     * @param locals
     * @param options
     */
    getMany<Type = any>(type: any, locals?: LocalsContainer, options?: Partial<InvokeOptions<Type>>): Type[];
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @returns {boolean}
     * @param token
     */
    has(token: TokenProvider): boolean;
    alias(token: TokenProvider, alias: TokenProvider): this;
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param options
     * @returns {T} The class constructed.
     */
    invoke<T = any>(token: TokenProvider, locals?: LocalsContainer, options?: Partial<InvokeOptions<T>>): T;
    /**
     * Build only providers which are asynchronous.
     */
    loadAsync(): Promise<void>;
    loadSync(): void;
    /**
     * Boostrap injector from container and resolve configuration.
     *
     * @param container
     */
    bootstrap(container?: Container): this;
    /**
     * Load injector from a given module
     * @param rootModule
     */
    loadModule(rootModule: TokenProvider): Promise<void>;
    /**
     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.
     *
     * @param container
     */
    load(container?: Container): Promise<void>;
    /**
     * Load all configurations registered on providers
     */
    resolveConfiguration(): void;
    /**
     *
     * @param instance
     * @param locals
     * @param options
     */
    bindInjectableProperties(instance: any, locals: LocalsContainer, options: Partial<InvokeOptions>): void;
    /**
     * Create an injectable property.
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     * @param resolver
     * @param options
     * @param locals
     * @param invokeOptions
     */
    bindProperty(instance: any, { propertyKey, resolver, options }: InjectablePropertyOptions, locals: LocalsContainer, invokeOptions: Partial<InvokeOptions>): void;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance: any, { propertyKey, expression, defaultValue }: InjectablePropertyValue): void;
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance: any, { propertyKey, expression, defaultValue }: InjectablePropertyValue): void;
    /**
     *
     * @param instance
     * @param propertyKey
     * @param useType
     * @param options
     */
    bindInterceptor(instance: any, { propertyKey, useType, options }: InjectablePropertyOptions): void;
    lazyInvoke<T = any>(token: TokenProvider): Promise<any>;
    /**
     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each service.
     * @returns {Promise<any[]>} A list of promises.
     */
    emit(eventName: string, ...args: any[]): Promise<void>;
    /**
     * @param eventName
     * @param value
     * @param args
     */
    alter<T = any>(eventName: string, value: any, ...args: any[]): T;
    /**
     * @param eventName
     * @param value
     * @param args
     */
    alterAsync<T = any>(eventName: string, value: any, ...args: any[]): Promise<T>;
    destroy(): Promise<void>;
    protected ensureProvider(token: TokenProvider): Provider | undefined;
    protected getInstance(token: any): any;
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * @param target
     * @param locals
     * @param options
     * @private
     */
    protected resolve<T>(target: TokenProvider, locals?: LocalsContainer, options?: Partial<InvokeOptions<T>>): T | Promise<T>;
    /**
     * Create options to invoke a provider or class.
     * @param token
     * @param locals
     * @param options
     */
    private mapInvokeOptions;
    private registerHooks;
}
