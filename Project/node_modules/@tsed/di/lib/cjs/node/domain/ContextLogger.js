"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextLogger = void 0;
const core_1 = require("@tsed/core");
const logger_1 = require("@tsed/logger");
const LEVELS = (0, logger_1.levels)();
class ContextLogger {
    dateStart;
    id;
    #additionalProps;
    maxStackSize;
    level;
    #hooks;
    #stack;
    #logger;
    constructor({ id, logger, dateStart = new Date(), level = "all", maxStackSize = 30, additionalProps }) {
        this.dateStart = dateStart;
        this.id = id;
        this.#logger = logger;
        this.#additionalProps = additionalProps;
        this.level = (LEVELS[level.toUpperCase()] || LEVELS.ALL);
        this.maxStackSize = maxStackSize;
    }
    get hooks() {
        return (this.#hooks = this.#hooks || new core_1.Hooks());
    }
    get stack() {
        return (this.#stack = this.#stack || []);
    }
    alterLog(cb) {
        return this.hooks.on("log", cb);
    }
    alterIgnoreLog(cb) {
        return this.hooks.on("ignore", cb);
    }
    info(obj) {
        this.run((0, logger_1.levels)().INFO, obj);
        return this;
    }
    debug(obj, withRequest = true) {
        this.run((0, logger_1.levels)().DEBUG, obj, withRequest);
        return this;
    }
    warn(obj) {
        this.run((0, logger_1.levels)().WARN, obj);
        return this;
    }
    error(obj) {
        this.run((0, logger_1.levels)().ERROR, obj);
        return this;
    }
    fatal(obj) {
        this.run((0, logger_1.levels)().FATAL, obj);
        return this;
    }
    trace(obj) {
        this.run((0, logger_1.levels)().TRACE, obj);
        return this;
    }
    flush(stream = false) {
        if (this.stack.length) {
            this.stack.forEach(({ level, data }) => {
                this.#logger[level](data);
            });
            this.#stack = [];
        }
        if (stream) {
            this.maxStackSize = 0;
        }
    }
    isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
    }
    /**
     * Return the duration between the time when LogIncomingRequest has handle the request and now.
     * @returns {number}
     */
    getDuration() {
        return new Date().getTime() - this.dateStart.getTime();
    }
    getData(obj) {
        if (typeof obj === "string") {
            obj = { message: obj };
        }
        return { ...this.#additionalProps, reqId: this.id, time: new Date(), duration: this.getDuration(), ...obj };
    }
    run(level, obj, withRequest) {
        if (!this.isLevelEnabled(level)) {
            return;
        }
        const ignore = this.#hooks?.alter("ignore", false, [obj]);
        if (!ignore) {
            const levelStr = level.levelStr.toLowerCase();
            obj = this.hooks.alter("log", this.getData(obj), [levelStr, withRequest]);
            this.stack.push({ level: levelStr, data: obj });
        }
        if (this.maxStackSize < this.stack.length || [(0, logger_1.levels)().FATAL, (0, logger_1.levels)().ERROR].includes(level)) {
            this.flush();
        }
    }
}
exports.ContextLogger = ContextLogger;
//# sourceMappingURL=ContextLogger.js.map