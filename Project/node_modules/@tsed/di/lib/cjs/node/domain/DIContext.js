"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIContext = void 0;
const index_1 = require("../../common/index");
const asyncHookContext_1 = require("../utils/asyncHookContext");
const ContextLogger_1 = require("./ContextLogger");
class DIContext {
    opts;
    #container;
    #cache;
    #logger;
    constructor(opts) {
        this.opts = opts;
    }
    /**
     * Logger attached to the context request.
     */
    get logger() {
        this.#logger = this.#logger || new ContextLogger_1.ContextLogger(this.opts);
        return this.#logger;
    }
    /**
     * Request id generated by @@contextMiddleware@@.
     *
     * ::: tip
     * By default Ts.ED generate uuid like that `uuidv4().replace(/-/gi, ""))`.
     * Dash are removed to simplify tracking logs in Kibana
     * :::
     *
     * ::: tip
     * Request id can by customized by changing the server configuration.
     *
     * ```typescript
     * @Configuration({
     *   logger: {
     *     reqIdBuilder: createUniqId // give your own id generator function
     *   }
     * })
     * class Server {
     *
     * }
     * ```
     * :::
     *
     */
    get id() {
        return this.opts.id;
    }
    get dateStart() {
        return this.logger.dateStart;
    }
    get injector() {
        return this.opts.injector;
    }
    get env() {
        return this.injector.settings.get("env");
    }
    /**
     * The request container used by the Ts.ED DI. It contains all services annotated with `@Scope(ProviderScope.REQUEST)`
     */
    get container() {
        return (this.#container = this.#container || new index_1.LocalsContainer());
    }
    destroy() {
        return Promise.all([this.#container?.destroy(), this.#logger?.flush(true)]);
    }
    emit(eventName, ...args) {
        return this.injector?.emit(eventName, ...args);
    }
    runInContext(next) {
        return (0, asyncHookContext_1.runInContext)(this, next);
    }
    cache(key, cb) {
        if (!this.has(key)) {
            this.set(key, cb());
        }
        return this.get(key);
    }
    async cacheAsync(key, cb) {
        if (!this.has(key)) {
            this.set(key, await cb());
        }
        return this.get(key);
    }
    delete(key) {
        return !!this.#cache?.delete(key);
    }
    get(key) {
        return this.#cache?.get(key);
    }
    has(key) {
        return !!this.#cache?.has(key);
    }
    set(key, value) {
        this.#cache = this.#cache || new Map();
        this.#cache.set(key, value);
        return this;
    }
}
exports.DIContext = DIContext;
//# sourceMappingURL=DIContext.js.map