"use strict";
var InjectorService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectorService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const constants_1 = require("../constants/constants");
const configuration_1 = require("../decorators/configuration");
const injectable_1 = require("../decorators/injectable");
const Container_1 = require("../domain/Container");
const InjectablePropertyType_1 = require("../domain/InjectablePropertyType");
const LocalsContainer_1 = require("../domain/LocalsContainer");
const Provider_1 = require("../domain/Provider");
const ProviderScope_1 = require("../domain/ProviderScope");
const InjectionError_1 = require("../errors/InjectionError");
const UndefinedTokenError_1 = require("../errors/UndefinedTokenError");
const GlobalProviders_1 = require("../registries/GlobalProviders");
const createContainer_1 = require("../utils/createContainer");
const getConstructorDependencies_1 = require("../utils/getConstructorDependencies");
const resolveControllers_1 = require("../utils/resolveControllers");
const DIConfiguration_1 = require("./DIConfiguration");
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/di";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services are imported, you can load InjectorService.
 * const injector = new InjectorService()
 *
 * await injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 */
let InjectorService = InjectorService_1 = class InjectorService extends Container_1.Container {
    settings = new DIConfiguration_1.DIConfiguration();
    logger = console;
    resolvedConfiguration = false;
    #cache = new LocalsContainer_1.LocalsContainer();
    #hooks = new core_1.Hooks();
    constructor() {
        super();
        this.#cache.set(InjectorService_1, this);
    }
    get resolvers() {
        return this.settings.resolvers;
    }
    get scopes() {
        return this.settings.scopes || {};
    }
    /**
     * Retrieve default scope for a given provider.
     * @param provider
     */
    scopeOf(provider) {
        return provider.scope || this.scopes[provider.type] || ProviderScope_1.ProviderScope.SINGLETON;
    }
    /**
     * Return a list of instance build by the injector.
     */
    toArray() {
        return [...this.#cache.values()];
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param token The class or symbol registered in InjectorService.
     * @param options
     * @returns {boolean}
     */
    get(token, options = {}) {
        const instance = this.getInstance(token);
        if (instance !== undefined) {
            return instance;
        }
        if (!this.hasProvider(token)) {
            for (const resolver of this.resolvers) {
                const result = resolver.get(token, options);
                if (result !== undefined) {
                    return result;
                }
            }
        }
    }
    /**
     * Return all instance of the same provider type
     * @param type
     * @param locals
     * @param options
     */
    getMany(type, locals, options) {
        return this.getProviders(type).map((provider) => this.invoke(provider.token, locals, options));
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @returns {boolean}
     * @param token
     */
    has(token) {
        return this.#cache.get(token) !== undefined;
    }
    alias(token, alias) {
        this.#cache.set(alias, this.#cache.get(token));
        return this;
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param options
     * @returns {T} The class constructed.
     */
    invoke(token, locals, options = {}) {
        let instance = locals ? locals.get(token) : undefined;
        if (instance !== undefined) {
            return instance;
        }
        if (token === configuration_1.Configuration) {
            return this.settings;
        }
        instance = !options.rebuild ? this.getInstance(token) : undefined;
        if (instance != undefined) {
            return instance;
        }
        if (token === constants_1.DI_PARAM_OPTIONS) {
            return {};
        }
        const provider = this.ensureProvider(token);
        const set = (instance) => {
            this.#cache.set(token, instance);
            provider?.alias && this.alias(token, provider.alias);
        };
        if (!provider || options.rebuild) {
            instance = this.resolve(token, locals, options);
            if (this.hasProvider(token)) {
                set(instance);
            }
            return instance;
        }
        instance = this.resolve(token, locals, options);
        switch (this.scopeOf(provider)) {
            case ProviderScope_1.ProviderScope.SINGLETON:
                if (provider.hooks && !options.rebuild) {
                    this.registerHooks(provider, instance);
                }
                if (!provider.isAsync() || !(0, core_1.isPromise)(instance)) {
                    set(instance);
                    return instance;
                }
                // store promise to lock token in cache
                set(instance);
                instance = instance.then((instance) => {
                    set(instance);
                    return instance;
                });
                return instance;
            case ProviderScope_1.ProviderScope.REQUEST:
                if (locals) {
                    locals.set(token, instance);
                    if (provider.hooks && provider.hooks.$onDestroy) {
                        locals.hooks.on("$onDestroy", (...args) => provider.hooks.$onDestroy(instance, ...args));
                    }
                }
                return instance;
        }
        return instance;
    }
    /**
     * Build only providers which are asynchronous.
     */
    async loadAsync() {
        for (const [, provider] of this) {
            if (!this.has(provider.token) && provider.isAsync()) {
                await this.invoke(provider.token);
            }
        }
    }
    loadSync() {
        for (const [, provider] of this) {
            if (!this.has(provider.token) && this.scopeOf(provider) === ProviderScope_1.ProviderScope.SINGLETON) {
                this.invoke(provider.token);
            }
        }
    }
    /**
     * Boostrap injector from container and resolve configuration.
     *
     * @param container
     */
    bootstrap(container = (0, createContainer_1.createContainer)()) {
        // Clone all providers in the container
        this.addProviders(container);
        // Resolve all configuration
        this.resolveConfiguration();
        // allow mocking or changing provider instance before loading injector
        this.settings.imports = this.settings.imports
            ?.filter((meta) => meta.token !== InjectorService_1)
            .map((meta) => {
            if ("token" in meta && "use" in meta) {
                const { token, use } = meta;
                const provider = this.getProvider(token);
                if (provider) {
                    provider.useValue = use;
                    // @ts-ignore
                    provider.useFactory = undefined;
                    // @ts-ignore
                    provider.useAsyncFactory = undefined;
                    // @ts-ignore
                    provider.useClass = undefined;
                    return;
                }
            }
            return meta;
        })
            .filter(Boolean);
        return this;
    }
    /**
     * Load injector from a given module
     * @param rootModule
     */
    loadModule(rootModule) {
        this.settings.routes = this.settings.routes.concat((0, resolveControllers_1.resolveControllers)(this.settings));
        const container = (0, createContainer_1.createContainer)();
        container.delete(rootModule);
        container.addProvider(rootModule, {
            type: "server:module",
            scope: ProviderScope_1.ProviderScope.SINGLETON
        });
        return this.load(container);
    }
    /**
     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.
     *
     * @param container
     */
    async load(container = (0, createContainer_1.createContainer)()) {
        this.bootstrap(container);
        // build async and sync provider
        await this.loadAsync();
        // load sync provider
        this.loadSync();
        await this.emit("$beforeInit");
        await this.emit("$onInit");
    }
    /**
     * Load all configurations registered on providers
     */
    resolveConfiguration() {
        if (this.resolvedConfiguration) {
            return;
        }
        const mergedConfiguration = new Map();
        super.forEach((provider) => {
            if (provider.configuration && provider.type !== "server:module") {
                Object.entries(provider.configuration).forEach(([key, value]) => {
                    if (!["resolvers", "mount", "imports"].includes(key)) {
                        value = mergedConfiguration.has(key) ? (0, core_1.deepMerge)(mergedConfiguration.get(key), value) : (0, core_1.deepClone)(value);
                        mergedConfiguration.set(key, value);
                    }
                });
            }
            if (provider.resolvers) {
                this.settings.resolvers = this.settings.resolvers.concat(provider.resolvers);
            }
        });
        mergedConfiguration.forEach((value, key) => {
            this.settings.set(key, (0, core_1.deepMerge)(value, this.settings.get(key)));
        });
        this.resolvedConfiguration = true;
    }
    /**
     *
     * @param instance
     * @param locals
     * @param options
     */
    bindInjectableProperties(instance, locals, options) {
        const properties = (0, core_1.ancestorsOf)((0, core_1.classOf)(instance)).reduce((properties, target) => {
            const store = core_1.Store.from(target);
            return {
                ...properties,
                ...(store.get(constants_1.INJECTABLE_PROP) || {})
            };
        }, {});
        Object.values(properties).forEach((definition) => {
            switch (definition.bindingType) {
                case InjectablePropertyType_1.InjectablePropertyType.PROPERTY:
                    this.bindProperty(instance, definition, locals, options);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.CONSTANT:
                    this.bindConstant(instance, definition);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.VALUE:
                    this.bindValue(instance, definition);
                    break;
                case InjectablePropertyType_1.InjectablePropertyType.INTERCEPTOR:
                    this.bindInterceptor(instance, definition);
                    break;
            }
        });
    }
    /**
     * Create an injectable property.
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     * @param resolver
     * @param options
     * @param locals
     * @param invokeOptions
     */
    bindProperty(instance, { propertyKey, resolver, options = {} }, locals, invokeOptions) {
        let get;
        get = resolver(this, locals, { ...invokeOptions, options });
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, {
            get
        }));
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance, { propertyKey, expression, defaultValue }) {
        const descriptor = {
            get: () => this.settings.get(expression) || defaultValue,
            set: (value) => this.settings.set(expression, value),
            enumerable: true,
            configurable: true
        };
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, descriptor));
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance, { propertyKey, expression, defaultValue }) {
        let bean;
        const get = () => {
            if (bean !== undefined) {
                return bean;
            }
            const value = this.settings.get(expression, defaultValue);
            bean = Object.freeze((0, core_1.deepClone)(value));
            return bean;
        };
        const descriptor = {
            get,
            enumerable: true,
            configurable: true
        };
        (0, core_1.catchError)(() => Object.defineProperty(instance, propertyKey, descriptor));
    }
    /**
     *
     * @param instance
     * @param propertyKey
     * @param useType
     * @param options
     */
    bindInterceptor(instance, { propertyKey, useType, options }) {
        const target = (0, core_1.classOf)(instance);
        const originalMethod = instance[propertyKey];
        instance[propertyKey] = (...args) => {
            const next = (err) => {
                if (!err) {
                    return originalMethod.apply(instance, args);
                }
                throw err;
            };
            const context = {
                target,
                propertyKey,
                args,
                options,
                next
            };
            const interceptor = this.get(useType);
            return interceptor.intercept({
                ...context,
                options
            }, next);
        };
    }
    async lazyInvoke(token) {
        let instance = this.getInstance(token);
        if (!instance) {
            instance = await this.invoke(token);
            if ((0, core_1.isFunction)(instance?.$onInit)) {
                await instance.$onInit();
            }
        }
        return instance;
    }
    /**
     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).
     * @param eventName The event name to emit at all services.
     * @param args List of the parameters to give to each service.
     * @returns {Promise<any[]>} A list of promises.
     */
    emit(eventName, ...args) {
        return this.#hooks.asyncEmit(eventName, args);
    }
    /**
     * @param eventName
     * @param value
     * @param args
     */
    alter(eventName, value, ...args) {
        return this.#hooks.alter(eventName, value, args);
    }
    /**
     * @param eventName
     * @param value
     * @param args
     */
    alterAsync(eventName, value, ...args) {
        return this.#hooks.asyncAlter(eventName, value, args);
    }
    destroy() {
        return this.emit("$onDestroy");
    }
    ensureProvider(token) {
        if (!this.hasProvider(token) && GlobalProviders_1.GlobalProviders.has(token)) {
            this.addProvider(token);
        }
        return this.getProvider(token);
    }
    getInstance(token) {
        return this.#cache.get(token);
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * @param target
     * @param locals
     * @param options
     * @private
     */
    resolve(target, locals = new LocalsContainer_1.LocalsContainer(), options = {}) {
        const resolvedOpts = this.mapInvokeOptions(target, locals, options);
        if (!resolvedOpts) {
            return undefined;
        }
        const { token, deps, construct, imports, provider } = resolvedOpts;
        if (provider) {
            GlobalProviders_1.GlobalProviders.onInvoke(provider, locals, { ...resolvedOpts, injector: this });
        }
        let instance;
        let currentDependency = false;
        try {
            const invokeDependency = (parent) => (token, index) => {
                currentDependency = { token, index, deps };
                if (token !== constants_1.DI_PARAM_OPTIONS) {
                    const options = provider?.store?.get(`${constants_1.DI_PARAM_OPTIONS}:${index}`);
                    locals.set(constants_1.DI_PARAM_OPTIONS, options || {});
                }
                if ((0, core_1.isArray)(token)) {
                    return this.getMany(token[0], locals, options);
                }
                return (0, core_1.isInheritedFrom)(token, Provider_1.Provider, 1) ? provider : this.invoke(token, locals, { parent });
            };
            // Invoke manually imported providers
            imports.forEach(invokeDependency());
            // Inject dependencies
            const services = deps.map(invokeDependency(token));
            currentDependency = false;
            instance = construct(services);
        }
        catch (error) {
            InjectionError_1.InjectionError.throwInjectorError(token, currentDependency, error);
        }
        if (instance === undefined) {
            throw new InjectionError_1.InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${(0, core_1.nameOf)(token)}`);
        }
        if (instance && (0, core_1.isClass)((0, core_1.classOf)(instance))) {
            this.bindInjectableProperties(instance, locals, options);
        }
        return instance;
    }
    /**
     * Create options to invoke a provider or class.
     * @param token
     * @param locals
     * @param options
     */
    mapInvokeOptions(token, locals, options) {
        let imports = options.imports;
        let deps = options.deps;
        let scope = options.scope;
        let construct;
        if (!token || token === Object) {
            throw new UndefinedTokenError_1.UndefinedTokenError();
        }
        let provider;
        if (!this.hasProvider(token)) {
            provider = new Provider_1.Provider(token);
            this.resolvers.forEach((resolver) => {
                const result = resolver.get(token, locals.get(constants_1.DI_PARAM_OPTIONS));
                if (result !== undefined) {
                    provider.useFactory = () => result;
                }
            });
        }
        else {
            provider = this.getProvider(token);
        }
        scope = scope || this.scopeOf(provider);
        deps = deps || provider.deps;
        imports = imports || provider.imports;
        if (provider.useValue !== undefined) {
            construct = () => ((0, core_1.isFunction)(provider.useValue) ? provider.useValue() : provider.useValue);
        }
        else if (provider.useFactory) {
            construct = (deps) => provider.useFactory(...deps);
        }
        else if (provider.useAsyncFactory) {
            construct = async (deps) => {
                deps = await Promise.all(deps);
                return provider.useAsyncFactory(...deps);
            };
        }
        else if (provider.useClass) {
            // useClass
            deps = deps || (0, getConstructorDependencies_1.getConstructorDependencies)(provider.useClass);
            construct = (deps) => new provider.useClass(...deps);
        }
        else {
            return false;
        }
        return {
            token,
            scope: scope || core_1.Store.from(token).get("scope") || ProviderScope_1.ProviderScope.SINGLETON,
            deps: deps || [],
            imports: imports || [],
            construct,
            provider
        };
    }
    registerHooks(provider, instance) {
        if (provider.hooks) {
            Object.entries(provider.hooks).forEach(([event, cb]) => {
                const callback = (...args) => cb(this.get(provider.token) || instance, ...args);
                this.#hooks.on(event, callback);
            });
        }
    }
};
InjectorService = InjectorService_1 = tslib_1.__decorate([
    (0, injectable_1.Injectable)({
        scope: ProviderScope_1.ProviderScope.SINGLETON,
        global: true
    }),
    tslib_1.__metadata("design:paramtypes", [])
], InjectorService);
exports.InjectorService = InjectorService;
//# sourceMappingURL=InjectorService.js.map