import { classOf, getClassOrSymbol, isClass, methodsOf, nameOf, Store } from "@tsed/core";
import { ProviderScope } from "./ProviderScope.js";
import { ProviderType } from "./ProviderType.js";
export class Provider {
    /**
     * Token group provider to retrieve all provider from the same type
     */
    type = ProviderType.PROVIDER;
    deps;
    imports;
    alias;
    useFactory;
    useAsyncFactory;
    useValue;
    hooks;
    _useClass;
    _provide;
    _store;
    _tokenStore;
    constructor(token, options = {}) {
        this.provide = token;
        this.useClass = token;
        Object.assign(this, options);
    }
    get token() {
        return this._provide;
    }
    get provide() {
        return this._provide;
    }
    set provide(value) {
        if (value) {
            this._provide = getClassOrSymbol(value);
            this._tokenStore = this._store = Store.from(value);
        }
    }
    get useClass() {
        return this._useClass;
    }
    /**
     * Create a new store if the given value is a class. Otherwise the value is ignored.
     * @param value
     */
    set useClass(value) {
        if (isClass(value)) {
            this._useClass = classOf(value);
            this._store = Store.from(value);
            this.hooks = methodsOf(this._useClass).reduce((hooks, { propertyKey }) => {
                if (String(propertyKey).startsWith("$")) {
                    return {
                        ...hooks,
                        [propertyKey]: (instance, ...args) => instance[propertyKey](...args)
                    };
                }
                return hooks;
            }, {});
        }
    }
    get className() {
        return this.name;
    }
    get name() {
        return nameOf(this.provide);
    }
    get store() {
        return this._store;
    }
    get path() {
        return this.store.get("path", "/");
    }
    set path(path) {
        this.store.set("path", path);
    }
    /**
     * Get the scope of the provider.
     *
     * ::: tip Note
     * Async provider is always a SINGLETON
     * :::
     *
     * @returns {boolean}
     */
    get scope() {
        if (this.isAsync()) {
            return ProviderScope.SINGLETON;
        }
        return this.get("scope");
    }
    /**
     * Change the scope value of the provider.
     * @param scope
     */
    set scope(scope) {
        this.store.set("scope", scope);
    }
    get configuration() {
        return this.get("configuration");
    }
    set configuration(configuration) {
        this.store.set("configuration", configuration);
    }
    get children() {
        return this.store.get("childrenControllers", []);
    }
    get(key) {
        return this.store.get(key) || this._tokenStore.get(key);
    }
    isAsync() {
        return !!this.useAsyncFactory;
    }
    clone() {
        return new (classOf(this))(this._provide, this);
    }
    /**
     *
     * @returns {boolean}
     */
    hasChildren() {
        return !!this.children.length;
    }
    /**
     *
     * @returns {boolean}
     */
    hasParent() {
        return !!this.store.get("parentController");
    }
    toString() {
        return [
            "Token",
            this.name,
            this.useClass && nameOf(this.useClass),
            this.useFactory && "Factory",
            this.useValue && "Value",
            this.useAsyncFactory && "AsyncFactory"
        ]
            .filter(Boolean)
            .join(":");
    }
}
//# sourceMappingURL=Provider.js.map