"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformLogMiddleware = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const platform_middlewares_1 = require("@tsed/platform-middlewares");
const platform_params_1 = require("@tsed/platform-params");
/**
 * @middleware
 * @platform
 */
let PlatformLogMiddleware = class PlatformLogMiddleware {
    requestFields;
    logRequest;
    logStart;
    logEnd;
    logLevel;
    get settings() {
        return this;
    }
    /**
     * Handle the request.
     */
    use(ctx) {
        this.configureRequest(ctx);
        this.onLogStart(ctx);
        ctx.response.onEnd(() => this.onLogEnd(ctx));
    }
    /**
     * Called when the `$onResponse` is called by Ts.ED (through Express.end).
     */
    onLogEnd(ctx) {
        const { logRequest, logEnd, logLevel } = this.settings;
        const started = ctx.logStarted;
        if (logEnd && started) {
            if (ctx.response.statusCode >= 400) {
                ctx.logger.error({
                    event: "request.end",
                    status: ctx.response.statusCode,
                    status_code: String(ctx.response.statusCode),
                    state: "KO",
                    ...(0, core_1.cleanObject)({
                        error_name: ctx.error?.name || ctx.error?.code,
                        error_message: ctx.error?.message,
                        error_errors: ctx.error?.errors,
                        error_stack: ctx.error?.stack,
                        error_body: ctx.error?.body,
                        error_headers: ctx.error?.headers
                    })
                });
            }
            else {
                if (logLevel === "debug") {
                    ctx.logger.debug({
                        event: "request.end",
                        status: ctx.response.statusCode,
                        status_code: String(ctx.response.statusCode),
                        data: ctx.data,
                        state: "OK"
                    });
                }
                else if (logRequest) {
                    ctx.logger.info({
                        event: "request.end",
                        status: ctx.response.statusCode,
                        status_code: String(ctx.response.statusCode),
                        state: "OK"
                    });
                }
            }
        }
    }
    /**
     * The separate onLogStart() function will allow developer to overwrite the initial request log.
     * @param ctx
     */
    onLogStart(ctx) {
        const { logRequest, logLevel, logStart } = this.settings;
        ctx.logStarted = true;
        if (logStart) {
            if (logLevel === "debug") {
                ctx.logger.debug({
                    event: "request.start"
                });
            }
            else if (logRequest) {
                ctx.logger.info({
                    event: "request.start"
                });
            }
        }
    }
    /**
     * Attach all information that will be necessary to log the request. Attach a new `request.log` object.
     */
    configureRequest(ctx) {
        ctx.logger.alterLog((obj, level, withRequest) => {
            switch (level) {
                case "info":
                    return { ...this.minimalRequestPicker(ctx), ...obj };
                case "debug":
                    return withRequest ? { ...this.requestToObject(ctx), ...obj } : obj;
                default:
                    return { ...this.requestToObject(ctx), ...obj };
            }
        });
    }
    /**
     * Return complete request info.
     * @returns {Object}
     * @param ctx
     */
    requestToObject(ctx) {
        const { request } = ctx;
        return {
            method: request.method,
            url: request.url,
            route: request.route || request.url,
            headers: request.headers,
            body: request.body,
            query: request.query,
            params: request.params
        };
    }
    /**
     * Return a filtered request from global configuration.
     * @returns {Object}
     * @param ctx
     */
    minimalRequestPicker(ctx) {
        const { requestFields } = this;
        const info = this.requestToObject(ctx);
        return requestFields.reduce((acc, key) => {
            acc[key] = info[key];
            return acc;
        }, {});
    }
};
tslib_1.__decorate([
    (0, di_1.Constant)("logger.requestFields", ["reqId", "method", "url", "duration", "route"]),
    tslib_1.__metadata("design:type", Array)
], PlatformLogMiddleware.prototype, "requestFields", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("logger.logRequest", true),
    tslib_1.__metadata("design:type", Boolean)
], PlatformLogMiddleware.prototype, "logRequest", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("logger.logStart", true),
    tslib_1.__metadata("design:type", Boolean)
], PlatformLogMiddleware.prototype, "logStart", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("logger.logEnd", true),
    tslib_1.__metadata("design:type", Boolean)
], PlatformLogMiddleware.prototype, "logEnd", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("logger.level"),
    tslib_1.__metadata("design:type", String)
], PlatformLogMiddleware.prototype, "logLevel", void 0);
tslib_1.__decorate([
    tslib_1.__param(0, (0, platform_params_1.Context)()),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], PlatformLogMiddleware.prototype, "use", null);
PlatformLogMiddleware = tslib_1.__decorate([
    (0, platform_middlewares_1.Middleware)()
], PlatformLogMiddleware);
exports.PlatformLogMiddleware = PlatformLogMiddleware;
//# sourceMappingURL=PlatformLogMiddleware.js.map