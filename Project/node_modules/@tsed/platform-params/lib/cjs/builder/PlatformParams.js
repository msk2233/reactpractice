"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformParams = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const ParamValidationError_1 = require("../errors/ParamValidationError");
const ParseExpressionPipe_1 = require("../pipes/ParseExpressionPipe");
/**
 * Platform Params abstraction layer.
 * @platform
 */
let PlatformParams = class PlatformParams {
    injector;
    getPipes(param) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        const map = (token) => this.injector.get(token);
        return [ParseExpressionPipe_1.ParseExpressionPipe, ...param.pipes.sort(sort)].map(map).filter(Boolean);
    }
    /**
     * Return a handler with injectable parameters
     * @param handlerMetadata
     */
    compileHandler({ propertyKey, token, handler }) {
        if (!token || !propertyKey) {
            return (scope) => handler(scope.$ctx);
        }
        const store = schema_1.JsonMethodStore.fromMethod(token, propertyKey);
        const getArguments = this.compile(store);
        const provider = this.injector.getProvider(token);
        return async (scope) => {
            const container = provider.scope === di_1.ProviderScope.REQUEST ? scope.$ctx.container : undefined;
            const [instance, args] = await Promise.all([this.injector.invoke(token, container), getArguments(scope)]);
            return instance[propertyKey].call(instance, ...args, scope.$ctx);
        };
    }
    compile(entity) {
        const params = schema_1.JsonParameterStore.getParams(entity.target, entity.propertyKey);
        const argsPipes = params.map((param) => {
            return {
                param,
                pipes: this.getPipes(param)
            };
        });
        return (scope) => {
            const promises = argsPipes.map(({ param, pipes }) => this.getArg(scope, pipes, param));
            return Promise.all(promises);
        };
    }
    getArg(scope, pipes, param) {
        return pipes.reduce(async (value, pipe) => {
            value = await value;
            try {
                return await pipe.transform(value, param);
            }
            catch (er) {
                throw ParamValidationError_1.ParamValidationError.from(param, er);
            }
        }, scope);
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformParams.prototype, "injector", void 0);
PlatformParams = tslib_1.__decorate([
    (0, di_1.Injectable)({
        scope: di_1.ProviderScope.SINGLETON,
        imports: [ParseExpressionPipe_1.ParseExpressionPipe]
    })
], PlatformParams);
exports.PlatformParams = PlatformParams;
//# sourceMappingURL=PlatformParams.js.map