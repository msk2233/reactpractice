import { __decorate, __metadata } from "tslib";
import { Inject, Injectable, InjectorService, ProviderScope } from "@tsed/di";
import { JsonMethodStore, JsonParameterStore } from "@tsed/schema";
import { ParamValidationError } from "../errors/ParamValidationError.js";
import { ParseExpressionPipe } from "../pipes/ParseExpressionPipe.js";
/**
 * Platform Params abstraction layer.
 * @platform
 */
let PlatformParams = class PlatformParams {
    injector;
    getPipes(param) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        const map = (token) => this.injector.get(token);
        return [ParseExpressionPipe, ...param.pipes.sort(sort)].map(map).filter(Boolean);
    }
    /**
     * Return a handler with injectable parameters
     * @param handlerMetadata
     */
    compileHandler({ propertyKey, token, handler }) {
        if (!token || !propertyKey) {
            return (scope) => handler(scope.$ctx);
        }
        const store = JsonMethodStore.fromMethod(token, propertyKey);
        const getArguments = this.compile(store);
        const provider = this.injector.getProvider(token);
        return async (scope) => {
            const container = provider.scope === ProviderScope.REQUEST ? scope.$ctx.container : undefined;
            const [instance, args] = await Promise.all([this.injector.invoke(token, container), getArguments(scope)]);
            return instance[propertyKey].call(instance, ...args, scope.$ctx);
        };
    }
    compile(entity) {
        const params = JsonParameterStore.getParams(entity.target, entity.propertyKey);
        const argsPipes = params.map((param) => {
            return {
                param,
                pipes: this.getPipes(param)
            };
        });
        return (scope) => {
            const promises = argsPipes.map(({ param, pipes }) => this.getArg(scope, pipes, param));
            return Promise.all(promises);
        };
    }
    getArg(scope, pipes, param) {
        return pipes.reduce(async (value, pipe) => {
            value = await value;
            try {
                return await pipe.transform(value, param);
            }
            catch (er) {
                throw ParamValidationError.from(param, er);
            }
        }, scope);
    }
};
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], PlatformParams.prototype, "injector", void 0);
PlatformParams = __decorate([
    Injectable({
        scope: ProviderScope.SINGLETON,
        imports: [ParseExpressionPipe]
    })
], PlatformParams);
export { PlatformParams };
//# sourceMappingURL=PlatformParams.js.map