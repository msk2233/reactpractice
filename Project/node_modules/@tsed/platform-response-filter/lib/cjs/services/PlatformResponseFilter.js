"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformResponseFilter = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const ResponseFiltersContainer_1 = require("../domain/ResponseFiltersContainer");
const getContentType_1 = require("../utils/getContentType");
const renderView_1 = require("../utils/renderView");
/**
 * @platform
 */
let PlatformResponseFilter = class PlatformResponseFilter {
    types = new Map();
    injector;
    responseFilters;
    additionalProperties;
    get contentTypes() {
        return [...this.types.keys()];
    }
    $onInit() {
        ResponseFiltersContainer_1.ResponseFiltersContainer.forEach((token, type) => {
            if (this.responseFilters.includes(token)) {
                this.types.set(type, this.injector.get(token));
            }
        });
    }
    getBestContentType(data, ctx) {
        const contentType = (0, getContentType_1.getContentType)(data, ctx);
        if (ctx.request.get("Accept")) {
            const bestContentType = ctx.request.accepts([contentType].concat(this.contentTypes).filter(Boolean));
            if (bestContentType) {
                return [].concat(bestContentType).filter((type) => type !== "*/*")[0];
            }
        }
        return contentType;
    }
    /**
     * Call filters to transform data
     * @param data
     * @param ctx
     */
    transform(data, ctx) {
        const { response } = ctx;
        if (ctx.endpoint?.operation) {
            const bestContentType = this.getBestContentType(data, ctx);
            bestContentType && response.contentType(bestContentType);
            if (this.types.has(bestContentType)) {
                return this.types.get(bestContentType).transform(data, ctx);
            }
            if (this.types.has(getContentType_1.ANY_CONTENT_TYPE)) {
                return this.types.get(getContentType_1.ANY_CONTENT_TYPE).transform(data, ctx);
            }
        }
        return data;
    }
    /**
     * Serialize data before calling filters
     * @param data
     * @param ctx
     */
    async serialize(data, ctx) {
        const { response, endpoint } = ctx;
        if (endpoint) {
            if (endpoint.view) {
                data = await (0, renderView_1.renderView)(data, ctx);
            }
            else if ((0, core_1.isSerializable)(data)) {
                const responseOpts = endpoint.getResponseOptions(response.statusCode, {
                    includes: this.getIncludes(ctx)
                });
                data = (0, json_mapper_1.serialize)(data, {
                    useAlias: true,
                    additionalProperties: this.additionalProperties,
                    ...responseOpts,
                    endpoint: true
                });
            }
        }
        return data;
    }
    getIncludes(ctx) {
        if (ctx.request.query.includes) {
            return [].concat(ctx.request.query.includes).flatMap((include) => include.split(","));
        }
        return undefined;
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformResponseFilter.prototype, "injector", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("responseFilters", []),
    tslib_1.__metadata("design:type", Array)
], PlatformResponseFilter.prototype, "responseFilters", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("additionalProperties"),
    tslib_1.__metadata("design:type", Boolean)
], PlatformResponseFilter.prototype, "additionalProperties", void 0);
PlatformResponseFilter = tslib_1.__decorate([
    (0, di_1.Injectable)()
], PlatformResponseFilter);
exports.PlatformResponseFilter = PlatformResponseFilter;
//# sourceMappingURL=PlatformResponseFilter.js.map