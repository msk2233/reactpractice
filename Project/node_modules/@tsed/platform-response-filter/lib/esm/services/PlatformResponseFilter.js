import { __decorate, __metadata } from "tslib";
import { isSerializable } from "@tsed/core";
import { Constant, Inject, Injectable, InjectorService } from "@tsed/di";
import { serialize } from "@tsed/json-mapper";
import { ResponseFiltersContainer } from "../domain/ResponseFiltersContainer.js";
import { ANY_CONTENT_TYPE, getContentType } from "../utils/getContentType.js";
import { renderView } from "../utils/renderView.js";
/**
 * @platform
 */
let PlatformResponseFilter = class PlatformResponseFilter {
    types = new Map();
    injector;
    responseFilters;
    additionalProperties;
    get contentTypes() {
        return [...this.types.keys()];
    }
    $onInit() {
        ResponseFiltersContainer.forEach((token, type) => {
            if (this.responseFilters.includes(token)) {
                this.types.set(type, this.injector.get(token));
            }
        });
    }
    getBestContentType(data, ctx) {
        const contentType = getContentType(data, ctx);
        if (ctx.request.get("Accept")) {
            const bestContentType = ctx.request.accepts([contentType].concat(this.contentTypes).filter(Boolean));
            if (bestContentType) {
                return [].concat(bestContentType).filter((type) => type !== "*/*")[0];
            }
        }
        return contentType;
    }
    /**
     * Call filters to transform data
     * @param data
     * @param ctx
     */
    transform(data, ctx) {
        const { response } = ctx;
        if (ctx.endpoint?.operation) {
            const bestContentType = this.getBestContentType(data, ctx);
            bestContentType && response.contentType(bestContentType);
            if (this.types.has(bestContentType)) {
                return this.types.get(bestContentType).transform(data, ctx);
            }
            if (this.types.has(ANY_CONTENT_TYPE)) {
                return this.types.get(ANY_CONTENT_TYPE).transform(data, ctx);
            }
        }
        return data;
    }
    /**
     * Serialize data before calling filters
     * @param data
     * @param ctx
     */
    async serialize(data, ctx) {
        const { response, endpoint } = ctx;
        if (endpoint) {
            if (endpoint.view) {
                data = await renderView(data, ctx);
            }
            else if (isSerializable(data)) {
                const responseOpts = endpoint.getResponseOptions(response.statusCode, {
                    includes: this.getIncludes(ctx)
                });
                data = serialize(data, {
                    useAlias: true,
                    additionalProperties: this.additionalProperties,
                    ...responseOpts,
                    endpoint: true
                });
            }
        }
        return data;
    }
    getIncludes(ctx) {
        if (ctx.request.query.includes) {
            return [].concat(ctx.request.query.includes).flatMap((include) => include.split(","));
        }
        return undefined;
    }
};
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], PlatformResponseFilter.prototype, "injector", void 0);
__decorate([
    Constant("responseFilters", []),
    __metadata("design:type", Array)
], PlatformResponseFilter.prototype, "responseFilters", void 0);
__decorate([
    Constant("additionalProperties"),
    __metadata("design:type", Boolean)
], PlatformResponseFilter.prototype, "additionalProperties", void 0);
PlatformResponseFilter = __decorate([
    Injectable()
], PlatformResponseFilter);
export { PlatformResponseFilter };
//# sourceMappingURL=PlatformResponseFilter.js.map