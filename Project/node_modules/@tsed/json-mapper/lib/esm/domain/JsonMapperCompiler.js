import { ancestorsOf, classOf, getRandomId, hasJsonMethod, isClass, isCollection, isDate, isMomentObject, isMongooseObject, isNil, isObject, isObjectID, isString, nameOf, objectKeys } from "@tsed/core";
export class JsonMapperCompiler {
    /**
     * Cached mappers metadata
     * @protected
     */
    cache = new Map();
    /**
     * Cached executable mappers by his id
     * @protected
     */
    mappers = {};
    /**
     * Cached schemas
     * @protected
     */
    schemes = {};
    /**
     * Cached classes by his id
     * @protected
     */
    constructors = {};
    /**
     * Global variables available in the mapper
     * @protected
     */
    globals = {
        isCollection,
        isClass,
        isObject,
        classOf,
        nameOf,
        hasJsonMethod,
        isMongooseObject,
        isNil,
        isDate,
        objectKeys,
        isMomentObject
    };
    constructor() {
        this.addGlobal("alterIgnore", this.alterIgnore.bind(this));
        this.addGlobal("alterValue", this.alterValue.bind(this));
        this.addGlobal("execMapper", this.execMapper.bind(this));
        this.addGlobal("compileAndMap", this.map.bind(this));
    }
    addTypeMapper(model, fn) {
        const id = nameOf(model);
        this.cache.set(model, new Map().set("typeMapper", {
            id,
            fn
        }));
        this.mappers[id] = fn;
        return this;
    }
    removeTypeMapper(model) {
        const store = this.cache.get(model);
        if (store) {
            const { id } = store.get("typeMapper");
            delete this.mappers[id];
            this.cache.delete(model);
        }
    }
    addGlobal(key, value) {
        this.globals[key] = value;
        return this;
    }
    eval(mapper, { id, groupsId, model }) {
        this.addGlobal("cache", this.cache);
        const { globals, schemes } = this;
        const injectGlobals = Object.keys(globals)
            .map((name) => {
            return `const ${name} = globals.${name};`;
        })
            .join("\n");
        eval(`${injectGlobals};

    cache.get(model).set(groupsId, { id: '${id}', fn: ${mapper} })`);
        const store = this.cache.get(model).get(groupsId);
        this.mappers[id] = store.fn;
        return store;
    }
    createContext(options) {
        const { cache } = this;
        return {
            ...options,
            cache
        };
    }
    compile(model, groups, opts = {}) {
        const token = isString(model) ? model : this.getType(model);
        const groupsId = this.getGroupsId(groups);
        let storeGroups = this.cache.get(token) || this.cache.get(nameOf(token));
        if (!storeGroups) {
            storeGroups = new Map();
            this.cache.set(token, storeGroups);
        }
        if (storeGroups.has("typeMapper")) {
            return storeGroups.get("typeMapper");
        }
        // generate mapper for the given groups
        if (!storeGroups.has(groupsId)) {
            const id = this.getId(token, groupsId);
            // prevent circular dependencies
            storeGroups.set(groupsId, {
                id
            });
            const mapper = opts.mapper ? opts.mapper(id, groups) : this.createMapper(token, id, groups);
            try {
                return this.eval(mapper, { id, model: token, groupsId });
            }
            catch (err) {
                throw new Error(`Fail to compile mapper for ${nameOf(model)}. See the error above: ${err.message}.\n${mapper}`);
            }
        }
        return storeGroups.get(groupsId);
    }
    execMapper(id, value, options) {
        if (isObjectID(value)) {
            return value.toString();
        }
        return this.mappers[id](value, options);
    }
    getType(model) {
        if (!model) {
            return Object;
        }
        if (isClass(model) && !isCollection(model)) {
            const type = [Array, Map, Set].find((t) => ancestorsOf(model).includes(t));
            if (type) {
                return type;
            }
        }
        return model;
    }
    alterIgnore(id, options) {
        let result = this.schemes[id]?.$hooks?.alter("ignore", false, [options]);
        if (result) {
            return result;
        }
    }
    alterGroups(schema, groups) {
        if (groups !== false) {
            return schema.$hooks.alter("groups", false, [groups]);
        }
        return false;
    }
    getGroupsId(groups) {
        if (groups === false) {
            return "default";
        }
        if (groups.length === 0) {
            return "-";
        }
        return groups.join(",");
    }
    getId(model, groupsId) {
        return `${isString(model) ? model : nameOf(model)}:${getRandomId()}:${groupsId}`;
    }
    getSchemaId(id, propertyKey) {
        return `${id}:${propertyKey}`;
    }
}
//# sourceMappingURL=JsonMapperCompiler.js.map