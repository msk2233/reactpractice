"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonMapperCompiler = void 0;
const core_1 = require("@tsed/core");
class JsonMapperCompiler {
    /**
     * Cached mappers metadata
     * @protected
     */
    cache = new Map();
    /**
     * Cached executable mappers by his id
     * @protected
     */
    mappers = {};
    /**
     * Cached schemas
     * @protected
     */
    schemes = {};
    /**
     * Cached classes by his id
     * @protected
     */
    constructors = {};
    /**
     * Global variables available in the mapper
     * @protected
     */
    globals = {
        isCollection: core_1.isCollection,
        isClass: core_1.isClass,
        isObject: core_1.isObject,
        classOf: core_1.classOf,
        nameOf: core_1.nameOf,
        hasJsonMethod: core_1.hasJsonMethod,
        isMongooseObject: core_1.isMongooseObject,
        isNil: core_1.isNil,
        isDate: core_1.isDate,
        objectKeys: core_1.objectKeys,
        isMomentObject: core_1.isMomentObject
    };
    constructor() {
        this.addGlobal("alterIgnore", this.alterIgnore.bind(this));
        this.addGlobal("alterValue", this.alterValue.bind(this));
        this.addGlobal("execMapper", this.execMapper.bind(this));
        this.addGlobal("compileAndMap", this.map.bind(this));
    }
    addTypeMapper(model, fn) {
        const id = (0, core_1.nameOf)(model);
        this.cache.set(model, new Map().set("typeMapper", {
            id,
            fn
        }));
        this.mappers[id] = fn;
        return this;
    }
    removeTypeMapper(model) {
        const store = this.cache.get(model);
        if (store) {
            const { id } = store.get("typeMapper");
            delete this.mappers[id];
            this.cache.delete(model);
        }
    }
    addGlobal(key, value) {
        this.globals[key] = value;
        return this;
    }
    eval(mapper, { id, groupsId, model }) {
        this.addGlobal("cache", this.cache);
        const { globals, schemes } = this;
        const injectGlobals = Object.keys(globals)
            .map((name) => {
            return `const ${name} = globals.${name};`;
        })
            .join("\n");
        eval(`${injectGlobals};

    cache.get(model).set(groupsId, { id: '${id}', fn: ${mapper} })`);
        const store = this.cache.get(model).get(groupsId);
        this.mappers[id] = store.fn;
        return store;
    }
    createContext(options) {
        const { cache } = this;
        return {
            ...options,
            cache
        };
    }
    compile(model, groups, opts = {}) {
        const token = (0, core_1.isString)(model) ? model : this.getType(model);
        const groupsId = this.getGroupsId(groups);
        let storeGroups = this.cache.get(token) || this.cache.get((0, core_1.nameOf)(token));
        if (!storeGroups) {
            storeGroups = new Map();
            this.cache.set(token, storeGroups);
        }
        if (storeGroups.has("typeMapper")) {
            return storeGroups.get("typeMapper");
        }
        // generate mapper for the given groups
        if (!storeGroups.has(groupsId)) {
            const id = this.getId(token, groupsId);
            // prevent circular dependencies
            storeGroups.set(groupsId, {
                id
            });
            const mapper = opts.mapper ? opts.mapper(id, groups) : this.createMapper(token, id, groups);
            try {
                return this.eval(mapper, { id, model: token, groupsId });
            }
            catch (err) {
                throw new Error(`Fail to compile mapper for ${(0, core_1.nameOf)(model)}. See the error above: ${err.message}.\n${mapper}`);
            }
        }
        return storeGroups.get(groupsId);
    }
    execMapper(id, value, options) {
        if ((0, core_1.isObjectID)(value)) {
            return value.toString();
        }
        return this.mappers[id](value, options);
    }
    getType(model) {
        if (!model) {
            return Object;
        }
        if ((0, core_1.isClass)(model) && !(0, core_1.isCollection)(model)) {
            const type = [Array, Map, Set].find((t) => (0, core_1.ancestorsOf)(model).includes(t));
            if (type) {
                return type;
            }
        }
        return model;
    }
    alterIgnore(id, options) {
        let result = this.schemes[id]?.$hooks?.alter("ignore", false, [options]);
        if (result) {
            return result;
        }
    }
    alterGroups(schema, groups) {
        if (groups !== false) {
            return schema.$hooks.alter("groups", false, [groups]);
        }
        return false;
    }
    getGroupsId(groups) {
        if (groups === false) {
            return "default";
        }
        if (groups.length === 0) {
            return "-";
        }
        return groups.join(",");
    }
    getId(model, groupsId) {
        return `${(0, core_1.isString)(model) ? model : (0, core_1.nameOf)(model)}:${(0, core_1.getRandomId)()}:${groupsId}`;
    }
    getSchemaId(id, propertyKey) {
        return `${id}:${propertyKey}`;
    }
}
exports.JsonMapperCompiler = JsonMapperCompiler;
//# sourceMappingURL=JsonMapperCompiler.js.map