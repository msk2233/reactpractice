import { __decorate, __metadata } from "tslib";
import { resolve } from "path";
import { readFileSync } from "fs";
import { ViewEngine } from "../decorators/viewEngine.js";
import { Engine } from "./Engine.js";
import { getCachedEngine, getFromCache, importEngine, setToCache } from "../utils/cache.js";
let ReactEngine = class ReactEngine extends Engine {
    constructor(name, options) {
        super(name, options);
        this.patchRequire();
    }
    async $onInit() {
        await super.$onInit();
        await importEngine("react-dom/server", "ReactDOM");
        await importEngine("@babel/core", "babel");
    }
    get babel() {
        return getCachedEngine("babel");
    }
    get reactDOM() {
        return getCachedEngine("ReactDOM");
    }
    patchRequire() {
        if (require.extensions) {
            // Ensure JSX is transformed on require
            if (!require.extensions[".jsx"]) {
                require.extensions[".jsx"] = this.requireReact.bind(this);
            }
            // Supporting .react extension as well as test cases
            // Using .react extension is not recommended.
            if (!require.extensions[".react"]) {
                require.extensions[".react"] = this.requireReact.bind(this);
            }
        }
    }
    configure(options) {
        const base = options.base;
        delete options.base;
        const enableCache = options.cache;
        delete options.cache;
        const isNonStatic = options.isNonStatic;
        delete options.isNonStatic;
        return { base, enableCache, isNonStatic };
    }
    $compile(template, options) {
        // Assign HTML Base
        const { base, enableCache, isNonStatic } = this.configure(options);
        // Start Conversion
        const Code = this.requireReactString(template);
        const Factory = this.engine.createFactory(Code);
        return () => {
            const parsed = new Factory(options);
            const content = isNonStatic ? this.reactDOM.renderToString(parsed) : this.reactDOM.renderToStaticMarkup(parsed);
            if (base) {
                options.content = content;
                return this.renderWithBase(template, base, enableCache, options);
            }
            return content;
        };
    }
    async $compileFile(file, options) {
        // Assign HTML Base
        const { base, enableCache, isNonStatic } = this.configure(options);
        let path = resolve(file);
        delete require.cache[path];
        const ReactDOM = await importEngine("react-dom/server", "ReactDOM");
        const { default: Code } = await import(path);
        const Factory = this.engine.createFactory(Code);
        return () => {
            const parsed = new Factory(options);
            const content = isNonStatic ? ReactDOM.renderToString(parsed) : ReactDOM.renderToStaticMarkup(parsed);
            if (base) {
                options.content = content;
                return this.renderWithBase(file, base, enableCache, options);
            }
            return content;
        };
    }
    renderWithBase(key, base, enableCache, options) {
        const baseStr = getFromCache(key) || readFileSync(resolve(base), "utf8");
        if (enableCache) {
            setToCache(key, baseStr);
        }
        return this.reactBaseTmpl(baseStr, options);
    }
    transformFileSync(filename) {
        return this.babel.transformFileSync(filename, { presets: ["@babel/preset-react"] }).code;
    }
    transform(src) {
        return this.babel.transform(src, { presets: ["@babel/preset-react"] }).code;
    }
    requireReact(module, filename) {
        const compiled = this.transformFileSync(filename);
        return module._compile(compiled, filename);
    }
    requireReactString(src, filename) {
        if (!filename)
            filename = "";
        // @ts-ignore
        const m = new module.constructor();
        filename = filename || "";
        // Compile Using React
        const compiled = this.transform(src);
        // Compile as a module
        m.paths = module.paths;
        m._compile(compiled, filename);
        return m.exports;
    }
    reactBaseTmpl(data, options) {
        let exp;
        let regex;
        // Iterates through the keys in file object
        // and interpolate / replace {{key}} with it's value
        for (const k in options) {
            if (options.hasOwnProperty(k)) {
                exp = `{{${k}}}`;
                regex = new RegExp(exp, "g");
                if (data.match(regex)) {
                    data = data.replace(regex, options[k]);
                }
            }
        }
        return data;
    }
};
ReactEngine = __decorate([
    ViewEngine("react", {
        requires: ["react"]
    }),
    __metadata("design:paramtypes", [String, Object])
], ReactEngine);
export { ReactEngine };
//# sourceMappingURL=ReactEngine.js.map