import { cache, getCachedEngine, importEngine, read, readPartials } from "../utils/cache.js";
export class Engine {
    name;
    options;
    driverName;
    constructor(name, options) {
        this.name = name;
        this.options = options;
    }
    get engine() {
        return getCachedEngine(this.name);
    }
    async $onInit() {
        await this.importEngine(this.name, this.options);
    }
    compile(template, options) {
        options = this.$cacheOptions(template, options, false);
        return cache(options) || cache(options, this.$compile.call(this, template, options));
    }
    compileFile(file, options) {
        options = this.$cacheOptions(file, options, true);
        return cache(options) || cache(options, this.$compileFile.call(this, file, options));
    }
    async render(template, options) {
        const compile = await this.compile(template, options);
        return compile(options);
    }
    async renderFile(file, options) {
        const opts = await this.readPartials(file, options);
        const compile = await this.compileFile(file, opts);
        return compile(opts);
    }
    async readPartials(file, options) {
        options.filename = file;
        const partials = await readPartials(file, options);
        const opts = Object.assign({}, options);
        opts.partials = partials;
        return opts;
    }
    $cacheOptions(template, options, fromFile) {
        return options;
    }
    $compile(template, options) {
        return this.engine.compile(template, options);
    }
    async $compileFile(file, options) {
        const template = await read(file, options);
        return this.$compile(template, options);
    }
    async importEngine(name, options) {
        const reqs = [].concat(options.requires || [name]);
        for (const req of reqs) {
            try {
                await importEngine(req, name);
                this.driverName = req;
            }
            catch (er) { }
        }
    }
}
//# sourceMappingURL=Engine.js.map