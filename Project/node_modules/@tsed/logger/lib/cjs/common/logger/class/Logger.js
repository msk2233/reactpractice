"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const LoggerAppenders_1 = require("./LoggerAppenders");
const tableUtils_1 = require("../utils/tableUtils");
const LogEvent_1 = require("../../core/LogEvent");
const LogLevel_1 = require("../../core/LogLevel");
const LogContext_1 = require("../../core/LogContext");
class Logger {
    _name;
    /**
     *
     */
    constructor(_name = "default") {
        this._name = _name;
        this.level = "all";
    }
    _appenders = new LoggerAppenders_1.LoggerAppenders();
    get appenders() {
        return this._appenders;
    }
    _level;
    get level() {
        return this._level.toString();
    }
    set level(level) {
        this._level = LogLevel_1.LogLevel.getLevel(level, "debug");
    }
    /**
     *
     */
    _context = new LogContext_1.LogContext();
    get context() {
        return this._context;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    /**
     * Create stack trace  the lines of least Logger.
     * @returns {string}
     */
    static createStack() {
        const stack = new Error().stack.replace("Error\n", "");
        return stack
            .split("\n")
            .filter((line, index) => index >= 2)
            .join("\n");
    }
    isLevelEnabled(otherLevel) {
        return this._level.isLessThanOrEqualTo(otherLevel);
    }
    /**
     * Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf() (the arguments are all passed to util.format()).
     * @param data
     * @returns {any}
     */
    debug(...data) {
        return this.write((0, LogLevel_1.levels)().DEBUG, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    info(...data) {
        return this.write((0, LogLevel_1.levels)().INFO, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    warn(...data) {
        return this.write((0, LogLevel_1.levels)().WARN, data);
    }
    /**
     * Prints to stderr with newline. Multiple arguments can be passed, with the first used as the primary
     * message and all additional used as substitution values similar to printf() (the arguments are all
     * passed to util.format()).
     * @param data
     * @returns {any}
     */
    error(...data) {
        return this.write((0, LogLevel_1.levels)().ERROR, data);
    }
    fatal(...data) {
        return this.write((0, LogLevel_1.levels)().FATAL, data);
    }
    /**
     *
     * @param data
     * @returns {Logger}
     */
    trace(...data) {
        const stack = "\n" + Logger.createStack() + "\n";
        data.push(stack);
        return this.write((0, LogLevel_1.levels)().TRACE, data);
    }
    /**
     *
     */
    start() {
        this.level = "ALL";
        return this;
    }
    /**
     *
     */
    stop() {
        this.level = "OFF";
        return this;
    }
    /**
     *
     * @returns {Promise<any[]>}
     */
    shutdown() {
        this.stop();
        const promises = this.appenders
            .toArray()
            .filter((appender) => !!appender.instance.shutdown)
            .map((appender) => appender.instance.shutdown());
        return Promise.all(promises);
    }
    /**
     *
     * @param list
     * @param settings
     */
    drawTable(list, settings = {}) {
        return (0, tableUtils_1.drawTable)(list, settings);
    }
    /**
     *
     * @param list
     * @param settings
     * @returns {Logger}
     */
    printTable(list, settings = {}) {
        this.info(`\n${this.drawTable(list, settings)}`);
        return this;
    }
    /**
     *
     * @returns {Logger}
     */
    write(logLevel, data) {
        if (!this.isLevelEnabled(logLevel))
            return this;
        const logEvent = new LogEvent_1.LogEvent(this._name, logLevel, data, this._context);
        this.appenders.byLogLevel(logLevel).forEach((appender) => {
            appender.write(logEvent);
        });
        return this;
    }
}
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map