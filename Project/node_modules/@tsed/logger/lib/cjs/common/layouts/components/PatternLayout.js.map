{"version":3,"file":"PatternLayout.js","sourceRoot":"","sources":["../../../../../src/common/layouts/components/PatternLayout.ts"],"names":[],"mappings":";;;;AAAA,sDAAoD;AACpD,oDAA+C;AAE/C,4DAAuD;AAGvD,iDAA4C;AAE5C,MAAM,KAAK,GAAG,mEAAmE,CAAC;AAClF,MAAM,uBAAuB,GAAG,iBAAiB,CAAC;AAElD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCG;AAEI,IAAM,aAAa,GAAnB,MAAM,aAAc,SAAQ,uBAAU;IAClC,UAAU,CAAa;IACvB,OAAO,CAAiB;IACxB,QAAQ,CAAS;IAE1B,YAAY,MAAgC;QAC1C,KAAK,CAAC,MAAM,CAAC,CAAC;QAEd,IAAI,CAAC,QAAQ,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,uBAAuB,CAAC;QACtE,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,MAAM,CAAC,MAAO,CAAC;QACxC,IAAI,CAAC,UAAU,GAAG,IAAI,+BAAc,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,KAAK,EAAE,CAAC;IACzF,CAAC;IAED;;;;;OAKG;IACH,SAAS,CAAC,YAAsB,EAAE,cAAuB;QACvD,IAAI,eAAe,GAAG,EAAE,CAAC;QACzB,IAAI,MAAM,CAAC;QACX,IAAI,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC;QAEjC,6BAA6B;QAC7B,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YACpD,mCAAmC;YACnC,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC1B,MAAM,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,mBAAmB,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAEvB,oDAAoD;YACpD,IAAI,IAAI,EAAE,CAAC;gBACT,eAAe,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACrC,CAAC;iBAAM,CAAC;gBACN,0DAA0D;gBAC1D,0BAA0B;gBAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,mBAAmB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;gBACpF,eAAe,IAAI,IAAA,4BAAc,EAAC,WAAW,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;YACtE,CAAC;YACD,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACtE,CAAC;QACD,OAAO,eAAe,CAAC;IACzB,CAAC;IAEO,YAAY,GAAG,CAAC,mBAA2B,EAAE,YAAiB,EAAE,SAAc,EAAE,EAAE;QACxF,OAAO,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;IACvE,CAAC,CAAC;CACH,CAAA;AAlDY,sCAAa;wBAAb,aAAa;IADzB,IAAA,eAAM,EAAC,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC;;GACb,aAAa,CAkDzB","sourcesContent":["import {truncateAndPad} from \"../utils/StringUtils\";\nimport {BaseLayout} from \"../class/BaseLayout\";\nimport {IReplacers} from \"../interfaces/Replacers\";\nimport {LayoutReplacer} from \"../class/LayoutReplacer\";\nimport {LogEvent} from \"../../core/LogEvent\";\nimport {BasicLayoutConfiguration, TokensHandlers} from \"../interfaces/BasicLayoutConfiguration\";\nimport {Layout} from \"../decorators/layout\";\n\nconst regex = /%(-?[0-9]+)?(\\.?[0-9]+)?([[\\]cdhmnpjrzxy%])(\\{([^}]+)\\})?|([^%]+)/;\nconst TTCC_CONVERSION_PATTERN = \"%r %p %c - %m%n\";\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %j log data as JSON\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %x{[tokenname]} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layouts function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\n@Layout({name: \"pattern\"})\nexport class PatternLayout extends BaseLayout {\n  readonly #replacers: IReplacers;\n  readonly #tokens: TokensHandlers;\n  readonly #pattern: string;\n\n  constructor(config: BasicLayoutConfiguration) {\n    super(config);\n\n    this.#pattern = (config && config.pattern) || TTCC_CONVERSION_PATTERN;\n    this.#tokens = config && config.tokens!;\n    this.#replacers = new LayoutReplacer(this.#tokens, this.config.timezoneOffset).build();\n  }\n\n  /**\n   *\n   * @param loggingEvent\n   * @param timezoneOffset\n   * @returns {string}\n   */\n  transform(loggingEvent: LogEvent, timezoneOffset?: number): string {\n    let formattedString = \"\";\n    let result;\n    let searchString = this.#pattern;\n\n    /* eslint no-cond-assign:0 */\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      const padding = result[1];\n      const truncation = result[2];\n      const conversionCharacter = result[3];\n      const specifier = result[5];\n      const text = result[6];\n\n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        const replacement = this.replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  }\n\n  private replaceToken = (conversionCharacter: string, loggingEvent: any, specifier: any) => {\n    return this.#replacers[conversionCharacter](loggingEvent, specifier);\n  };\n}\n"]}