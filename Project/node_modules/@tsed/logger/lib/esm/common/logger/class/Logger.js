import { LoggerAppenders } from "./LoggerAppenders.js";
import { drawTable } from "../utils/tableUtils.js";
import { LogEvent } from "../../core/LogEvent.js";
import { levels, LogLevel } from "../../core/LogLevel.js";
import { LogContext } from "../../core/LogContext.js";
export class Logger {
    _name;
    /**
     *
     */
    constructor(_name = "default") {
        this._name = _name;
        this.level = "all";
    }
    _appenders = new LoggerAppenders();
    get appenders() {
        return this._appenders;
    }
    _level;
    get level() {
        return this._level.toString();
    }
    set level(level) {
        this._level = LogLevel.getLevel(level, "debug");
    }
    /**
     *
     */
    _context = new LogContext();
    get context() {
        return this._context;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    /**
     * Create stack trace  the lines of least Logger.
     * @returns {string}
     */
    static createStack() {
        const stack = new Error().stack.replace("Error\n", "");
        return stack
            .split("\n")
            .filter((line, index) => index >= 2)
            .join("\n");
    }
    isLevelEnabled(otherLevel) {
        return this._level.isLessThanOrEqualTo(otherLevel);
    }
    /**
     * Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf() (the arguments are all passed to util.format()).
     * @param data
     * @returns {any}
     */
    debug(...data) {
        return this.write(levels().DEBUG, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    info(...data) {
        return this.write(levels().INFO, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    warn(...data) {
        return this.write(levels().WARN, data);
    }
    /**
     * Prints to stderr with newline. Multiple arguments can be passed, with the first used as the primary
     * message and all additional used as substitution values similar to printf() (the arguments are all
     * passed to util.format()).
     * @param data
     * @returns {any}
     */
    error(...data) {
        return this.write(levels().ERROR, data);
    }
    fatal(...data) {
        return this.write(levels().FATAL, data);
    }
    /**
     *
     * @param data
     * @returns {Logger}
     */
    trace(...data) {
        const stack = "\n" + Logger.createStack() + "\n";
        data.push(stack);
        return this.write(levels().TRACE, data);
    }
    /**
     *
     */
    start() {
        this.level = "ALL";
        return this;
    }
    /**
     *
     */
    stop() {
        this.level = "OFF";
        return this;
    }
    /**
     *
     * @returns {Promise<any[]>}
     */
    shutdown() {
        this.stop();
        const promises = this.appenders
            .toArray()
            .filter((appender) => !!appender.instance.shutdown)
            .map((appender) => appender.instance.shutdown());
        return Promise.all(promises);
    }
    /**
     *
     * @param list
     * @param settings
     */
    drawTable(list, settings = {}) {
        return drawTable(list, settings);
    }
    /**
     *
     * @param list
     * @param settings
     * @returns {Logger}
     */
    printTable(list, settings = {}) {
        this.info(`\n${this.drawTable(list, settings)}`);
        return this;
    }
    /**
     *
     * @returns {Logger}
     */
    write(logLevel, data) {
        if (!this.isLevelEnabled(logLevel))
            return this;
        const logEvent = new LogEvent(this._name, logLevel, data, this._context);
        this.appenders.byLogLevel(logLevel).forEach((appender) => {
            appender.write(logEvent);
        });
        return this;
    }
}
//# sourceMappingURL=Logger.js.map