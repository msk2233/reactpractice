var Ie = Object.defineProperty;
var Le = (t, e, r) => e in t ? Ie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var y = (t, e, r) => (Le(t, typeof e != "symbol" ? e + "" : e, r), r), ue = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var pe = (t, e, r) => (ue(t, e, "read from private field"), r ? r.call(t) : e.get(t)), he = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, te = (t, e, r, n) => (ue(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
const ie = /* @__PURE__ */ new Map();
class de {
  static get(e, r) {
    typeof e != "string" && (e = e.$name), ie.has(e) || (e = "colored", console.warn(e + " layout doesn't exists"));
    const n = ie.get(e);
    return new n.provide(r);
  }
}
var U;
class Ue {
  constructor(e) {
    he(this, U, void 0);
    this.config = e, this.configure(e);
  }
  get appenderOptions() {
    return this.__proto__.constructor.$appenderOptions;
  }
  configure(e) {
    var r;
    return Object.assign(this.config, e), te(this, U, de.get(((r = this.appenderOptions) == null ? void 0 : r.defaultLayout) || "colored", this.config)), this.config.layout && te(this, U, de.get(this.config.layout.type, this.config.layout)), this;
  }
  /**
   *
   * @param args
   */
  layout(...e) {
    return pe(this, U).transform(...e);
  }
}
U = new WeakMap();
const oe = /* @__PURE__ */ new Map();
function Be(t) {
  return (e) => {
    e.$appenderOptions = t, e.$name = t.name, oe.set(t.name, { provide: e });
  };
}
var Je = Object.defineProperty, He = Object.getOwnPropertyDescriptor, We = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? He(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && Je(e, r, s), s;
};
let ge = class extends Ue {
  constructor() {
    super(...arguments);
    y(this, "log", console.log.bind(console));
  }
  write(e) {
    this.log(this.layout(e, this.config.timezoneOffset));
  }
};
ge = We([
  Be({ name: "console" })
], ge);
class Ze extends Map {
  toJSON() {
    return [...this.entries()].reduce((e, [r, n]) => ({
      ...e,
      [r]: n
    }), {});
  }
}
class Ve {
  /**
   * Models a logging event.
   * @constructor
   * @param categoryName
   * @param level
   * @param data
   * @param context
   */
  constructor(e, r, n, s) {
    y(this, "_startTime", /* @__PURE__ */ new Date());
    this.categoryName = e, this.level = r, this.data = n, this.context = s;
  }
  get startTime() {
    return this.data && this.data[0] && this.data[0].time ? this.data[0].time : this._startTime;
  }
  /**
   * @deprecated
   */
  get formatedLevel() {
    return this.formattedLevel;
  }
  get formattedLevel() {
    return (this.level.toString() + "     ").slice(0, 5);
  }
  get cluster() {
    return {};
  }
  get pid() {
    return this.context.get("pid");
  }
  isMessage() {
    return this.data.length && typeof this.data[0] != "object";
  }
  getData() {
    return this.isMessage() ? {} : this.data[0];
  }
  getMessage() {
    return this.isMessage() ? this.data : void 0;
  }
}
class T {
  constructor(e, r) {
    this.level = e, this.levelStr = r, this.level = e, this.levelStr = r;
  }
  static getLevel(e, r) {
    if (e instanceof T)
      return e;
    if (typeof e == "string") {
      const n = e.toUpperCase();
      return Te[n] || r;
    }
    return this.getLevel(e.toString());
  }
  toString() {
    return this.levelStr;
  }
  isLessThanOrEqualTo(e) {
    return typeof e == "string" && (e = T.getLevel(e)), this.level <= e.level;
  }
  isGreaterThanOrEqualTo(e) {
    return typeof e == "string" && (e = T.getLevel(e)), this.level >= e.level;
  }
  isEqualTo(e) {
    return typeof e == "string" && (e = T.getLevel(e)), this.level === e.level;
  }
}
const Te = {
  ALL: new T(Number.MIN_VALUE, "ALL"),
  TRACE: new T(5e3, "TRACE"),
  DEBUG: new T(1e4, "DEBUG"),
  INFO: new T(2e4, "INFO"),
  WARN: new T(3e4, "WARN"),
  ERROR: new T(4e4, "ERROR"),
  FATAL: new T(5e4, "FATAL"),
  MARK: new T(9007199254740992, "MARK"),
  // 2^53
  OFF: new T(Number.MAX_VALUE, "OFF")
};
function L() {
  return Te;
}
class C {
  constructor(e) {
    this.config = e;
  }
}
var Ye = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qe(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ee = { exports: {} };
(function(t) {
  function e(d, p) {
    for (var w = d.toString(); w.length < p; )
      w = "0" + w;
    return w;
  }
  function r(d) {
    return e(d, 2);
  }
  function n(d) {
    var p = Math.abs(d), w = String(Math.floor(p / 60)), b = String(p % 60);
    return w = ("0" + w).slice(-2), b = ("0" + b).slice(-2), d === 0 ? "Z" : (d < 0 ? "+" : "-") + w + ":" + b;
  }
  function s(d, p) {
    typeof d != "string" && (p = d, d = t.exports.ISO8601_FORMAT), p || (p = t.exports.now());
    var w = r(p.getDate()), b = r(p.getMonth() + 1), F = r(p.getFullYear()), $ = r(F.substring(2, 4)), z = d.indexOf("yyyy") > -1 ? F : $, A = r(p.getHours()), J = r(p.getMinutes()), R = r(p.getSeconds()), M = e(p.getMilliseconds(), 3), u = n(p.getTimezoneOffset()), c = d.replace(/dd/g, w).replace(/MM/g, b).replace(/y{1,4}/g, z).replace(/hh/g, A).replace(/mm/g, J).replace(/ss/g, R).replace(/SSS/g, M).replace(/O/g, u);
    return c;
  }
  function a(d, p, w, b) {
    d["set" + (b ? "" : "UTC") + p](w);
  }
  function f(d, p, w) {
    var b = d.indexOf("O") < 0, F = !1, $ = [
      {
        pattern: /y{1,4}/,
        regexp: "\\d{1,4}",
        fn: function(u, c) {
          a(u, "FullYear", c, b);
        }
      },
      {
        pattern: /MM/,
        regexp: "\\d{1,2}",
        fn: function(u, c) {
          a(u, "Month", c - 1, b), u.getMonth() !== c - 1 && (F = !0);
        }
      },
      {
        pattern: /dd/,
        regexp: "\\d{1,2}",
        fn: function(u, c) {
          F && a(u, "Month", u.getMonth() - 1, b), a(u, "Date", c, b);
        }
      },
      {
        pattern: /hh/,
        regexp: "\\d{1,2}",
        fn: function(u, c) {
          a(u, "Hours", c, b);
        }
      },
      {
        pattern: /mm/,
        regexp: "\\d\\d",
        fn: function(u, c) {
          a(u, "Minutes", c, b);
        }
      },
      {
        pattern: /ss/,
        regexp: "\\d\\d",
        fn: function(u, c) {
          a(u, "Seconds", c, b);
        }
      },
      {
        pattern: /SSS/,
        regexp: "\\d\\d\\d",
        fn: function(u, c) {
          a(u, "Milliseconds", c, b);
        }
      },
      {
        pattern: /O/,
        regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
        fn: function(u, c) {
          c === "Z" ? c = 0 : c = c.replace(":", "");
          var x = Math.abs(c), j = (c > 0 ? -1 : 1) * (x % 100 + Math.floor(x / 100) * 60);
          u.setUTCMinutes(u.getUTCMinutes() + j);
        }
      }
    ], z = $.reduce(
      function(u, c) {
        return c.pattern.test(u.regexp) ? (c.index = u.regexp.match(c.pattern).index, u.regexp = u.regexp.replace(c.pattern, "(" + c.regexp + ")")) : c.index = -1, u;
      },
      { regexp: d, index: [] }
    ), A = $.filter(function(u) {
      return u.index > -1;
    });
    A.sort(function(u, c) {
      return u.index - c.index;
    });
    var J = new RegExp(z.regexp), R = J.exec(p);
    if (R) {
      var M = w || t.exports.now();
      return A.forEach(function(u, c) {
        u.fn(M, R[c + 1]);
      }), M;
    }
    throw new Error(
      "String '" + p + "' could not be parsed as '" + d + "'"
    );
  }
  function E(d, p, w) {
    if (!d)
      throw new Error("pattern must be supplied");
    return f(d, p, w);
  }
  function m() {
    return /* @__PURE__ */ new Date();
  }
  t.exports = s, t.exports.asString = s, t.exports.parse = E, t.exports.now = m, t.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS", t.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO", t.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS", t.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
})(Ee);
var N = Ee.exports, G = /* @__PURE__ */ ((t) => (t.ALL = "grey", t.INFO = "green", t.DEBUG = "cyan", t.WARN = "yellow", t.TRACE = "blue", t.ERROR = "red", t.FATAL = "magenta", t.OFF = "grey", t))(G || {});
const Ae = {
  // styles
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  // grayscale
  white: [37, 39],
  grey: [90, 39],
  black: [90, 39],
  // colors
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
function Me(t) {
  return t ? `\x1B[${Ae[t][0]}m` : "";
}
function je(t) {
  return t ? `\x1B[${Ae[t][1]}m` : "";
}
function Ge(t, e) {
  return Me(e) + t + je(e);
}
function Ke(t) {
  return t.replace(/\[\d+m|\\u\d+b/gi, "");
}
function Xe(t, e) {
  let r;
  return t ? (r = parseInt(t.substr(1), 10), e.substring(0, r)) : e;
}
function Qe(t, e) {
  let r;
  if (t)
    if (t.charAt(0) === "-")
      for (r = parseInt(t.substr(1), 10); e.length < r; )
        e += " ";
    else
      for (r = parseInt(t, 10); e.length < r; )
        e = ` ${e}`;
  return e;
}
function ke(t, e, r) {
  let n = t;
  return n = Xe(e, n), n = Qe(r, n), n;
}
function et(t, ...e) {
  const r = /(%?)(%([ojds]))/g;
  if (e.length) {
    const n = (s, a, f, E) => {
      let m = e.shift();
      switch (E) {
        case "o":
          if (Array.isArray(m)) {
            m = JSON.stringify(m);
            break;
          }
        case "s":
          m = "" + m;
          break;
        case "d":
          m = Number(m);
          break;
        case "j":
          m = JSON.stringify(m);
          break;
      }
      return a ? (e.unshift(m), s) : m;
    };
    t = String(t).replace(r, n);
  }
  return e.length && (t += " " + e.join(" ")), t = String(t).replace(/%{2,2}/g, "%"), "" + t;
}
const P = class P {
  constructor(e, r) {
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    y(this, "categoryName", (e, r) => {
      let n = e.categoryName;
      if (r) {
        const s = parseInt(r, 10), a = n.split(".");
        s < a.length && (n = a.slice(a.length - s).join("."));
      }
      return n;
    });
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    y(this, "formatAsDate", (e, r) => {
      let n = N.ISO8601_FORMAT;
      return r && (n = r, n === "ISO8601" ? n = N.ISO8601_FORMAT : n === "ISO8601_WITH_TZ_OFFSET" ? n = N.ISO8601_WITH_TZ_OFFSET_FORMAT : n === "ABSOLUTE" ? n = N.ABSOLUTETIME_FORMAT : n === "DATE" && (n = N.DATETIME_FORMAT)), N.asString(n, e.startTime, this.timezoneOffset);
    });
    /**
     *
     * @returns {string}
     */
    y(this, "hostname", () => P.HOSTNAME || "");
    /**
     *
     * @param loggingEvent
     * @returns {any}
     */
    y(this, "formatMessage", (e) => P.formatter(...e.data));
    y(this, "formatJson", (e) => JSON.stringify(e.data));
    /**
     *
     * @returns {string|string}
     */
    y(this, "endOfLine", () => P.EOL);
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    y(this, "logLevel", (e) => e.level.toString());
    /**
     *
     * @param loggingEvent
     * @returns {any}
     */
    y(this, "startTime", (e) => N.asString("hh:mm:ss", e.startTime, this.timezoneOffset));
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    y(this, "startColour", (e) => {
      const r = e.level.toString();
      return Me(G[r]);
    });
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    y(this, "endColour", (e) => {
      const r = e.level.toString();
      return je(G[r]);
    });
    /**
     *
     * @returns {string}
     */
    y(this, "percent", () => "%");
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    y(this, "pid", (e) => e && e.pid ? e.pid.toString() : process.pid.toString());
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    y(this, "clusterInfo", (e, r) => e.cluster && r ? r.replace("%m", e.cluster.master).replace("%w", e.cluster.worker).replace("%i", e.cluster.workerId) : e.cluster ? `${e.cluster.worker}@${e.cluster.master}` : this.pid());
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    y(this, "userDefined", (e, r) => typeof this.tokens[r] < "u" ? typeof this.tokens[r] == "function" ? this.tokens[r](e) : this.tokens[r] : null);
    this.tokens = e, this.timezoneOffset = r;
  }
  build() {
    return {
      c: this.categoryName,
      d: this.formatAsDate,
      h: this.hostname,
      m: this.formatMessage,
      j: this.formatJson,
      n: this.endOfLine,
      p: this.logLevel,
      r: this.startTime,
      "[": this.startColour,
      "]": this.endColour,
      y: this.clusterInfo,
      z: this.pid,
      "%": this.percent,
      x: this.userDefined
    };
  }
};
y(P, "EOL", `
`), y(P, "HOSTNAME", ""), y(P, "formatter", et);
let ae = P;
var B = {}, tt = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
}, le = { exports: {} };
typeof Object.create == "function" ? le.exports = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : le.exports = function(e, r) {
  e.super_ = r;
  var n = function() {
  };
  n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
};
var rt = le.exports;
(function(t) {
  var e = /%[sdj%]/g;
  t.format = function(i) {
    if (!M(i)) {
      for (var o = [], l = 0; l < arguments.length; l++)
        o.push(s(arguments[l]));
      return o.join(" ");
    }
    for (var l = 1, g = arguments, S = g.length, v = String(i).replace(e, function(O) {
      if (O === "%%")
        return "%";
      if (l >= S)
        return O;
      switch (O) {
        case "%s":
          return String(g[l++]);
        case "%d":
          return Number(g[l++]);
        case "%j":
          try {
            return JSON.stringify(g[l++]);
          } catch {
            return "[Circular]";
          }
        default:
          return O;
      }
    }), h = g[l]; l < S; h = g[++l])
      A(h) || !j(h) ? v += " " + h : v += " " + s(h);
    return v;
  }, t.deprecate = function(i, o) {
    if (c(Ye.process))
      return function() {
        return t.deprecate(i, o).apply(this, arguments);
      };
    if (process.noDeprecation === !0)
      return i;
    var l = !1;
    function g() {
      if (!l) {
        if (process.throwDeprecation)
          throw new Error(o);
        process.traceDeprecation ? console.trace(o) : console.error(o), l = !0;
      }
      return i.apply(this, arguments);
    }
    return g;
  };
  var r = {}, n;
  t.debuglog = function(i) {
    if (c(n) && (n = process.env.NODE_DEBUG || ""), i = i.toUpperCase(), !r[i])
      if (new RegExp("\\b" + i + "\\b", "i").test(n)) {
        var o = process.pid;
        r[i] = function() {
          var l = t.format.apply(t, arguments);
          console.error("%s %d: %s", i, o, l);
        };
      } else
        r[i] = function() {
        };
    return r[i];
  };
  function s(i, o) {
    var l = {
      seen: [],
      stylize: f
    };
    return arguments.length >= 3 && (l.depth = arguments[2]), arguments.length >= 4 && (l.colors = arguments[3]), z(o) ? l.showHidden = o : o && t._extend(l, o), c(l.showHidden) && (l.showHidden = !1), c(l.depth) && (l.depth = 2), c(l.colors) && (l.colors = !1), c(l.customInspect) && (l.customInspect = !0), l.colors && (l.stylize = a), m(l, i, l.depth);
  }
  t.inspect = s, s.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, s.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function a(i, o) {
    var l = s.styles[o];
    return l ? "\x1B[" + s.colors[l][0] + "m" + i + "\x1B[" + s.colors[l][1] + "m" : i;
  }
  function f(i, o) {
    return i;
  }
  function E(i) {
    var o = {};
    return i.forEach(function(l, g) {
      o[l] = !0;
    }), o;
  }
  function m(i, o, l) {
    if (i.customInspect && o && W(o.inspect) && // Filter out the util module, it's inspect function is special
    o.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(o.constructor && o.constructor.prototype === o)) {
      var g = o.inspect(l, i);
      return M(g) || (g = m(i, g, l)), g;
    }
    var S = d(i, o);
    if (S)
      return S;
    var v = Object.keys(o), h = E(v);
    if (i.showHidden && (v = Object.getOwnPropertyNames(o)), H(o) && (v.indexOf("message") >= 0 || v.indexOf("description") >= 0))
      return p(o);
    if (v.length === 0) {
      if (W(o)) {
        var O = o.name ? ": " + o.name : "";
        return i.stylize("[Function" + O + "]", "special");
      }
      if (x(o))
        return i.stylize(RegExp.prototype.toString.call(o), "regexp");
      if (X(o))
        return i.stylize(Date.prototype.toString.call(o), "date");
      if (H(o))
        return p(o);
    }
    var _ = "", D = !1, Z = ["{", "}"];
    if ($(o) && (D = !0, Z = ["[", "]"]), W(o)) {
      var xe = o.name ? ": " + o.name : "";
      _ = " [Function" + xe + "]";
    }
    if (x(o) && (_ = " " + RegExp.prototype.toString.call(o)), X(o) && (_ = " " + Date.prototype.toUTCString.call(o)), H(o) && (_ = " " + p(o)), v.length === 0 && (!D || o.length == 0))
      return Z[0] + _ + Z[1];
    if (l < 0)
      return x(o) ? i.stylize(RegExp.prototype.toString.call(o), "regexp") : i.stylize("[Object]", "special");
    i.seen.push(o);
    var ee;
    return D ? ee = w(i, o, l, h, v) : ee = v.map(function(Ce) {
      return b(i, o, l, h, Ce, D);
    }), i.seen.pop(), F(ee, _, Z);
  }
  function d(i, o) {
    if (c(o))
      return i.stylize("undefined", "undefined");
    if (M(o)) {
      var l = "'" + JSON.stringify(o).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return i.stylize(l, "string");
    }
    if (R(o))
      return i.stylize("" + o, "number");
    if (z(o))
      return i.stylize("" + o, "boolean");
    if (A(o))
      return i.stylize("null", "null");
  }
  function p(i) {
    return "[" + Error.prototype.toString.call(i) + "]";
  }
  function w(i, o, l, g, S) {
    for (var v = [], h = 0, O = o.length; h < O; ++h)
      fe(o, String(h)) ? v.push(b(
        i,
        o,
        l,
        g,
        String(h),
        !0
      )) : v.push("");
    return S.forEach(function(_) {
      _.match(/^\d+$/) || v.push(b(
        i,
        o,
        l,
        g,
        _,
        !0
      ));
    }), v;
  }
  function b(i, o, l, g, S, v) {
    var h, O, _;
    if (_ = Object.getOwnPropertyDescriptor(o, S) || { value: o[S] }, _.get ? _.set ? O = i.stylize("[Getter/Setter]", "special") : O = i.stylize("[Getter]", "special") : _.set && (O = i.stylize("[Setter]", "special")), fe(g, S) || (h = "[" + S + "]"), O || (i.seen.indexOf(_.value) < 0 ? (A(l) ? O = m(i, _.value, null) : O = m(i, _.value, l - 1), O.indexOf(`
`) > -1 && (v ? O = O.split(`
`).map(function(D) {
      return "  " + D;
    }).join(`
`).substr(2) : O = `
` + O.split(`
`).map(function(D) {
      return "   " + D;
    }).join(`
`))) : O = i.stylize("[Circular]", "special")), c(h)) {
      if (v && S.match(/^\d+$/))
        return O;
      h = JSON.stringify("" + S), h.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (h = h.substr(1, h.length - 2), h = i.stylize(h, "name")) : (h = h.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), h = i.stylize(h, "string"));
    }
    return h + ": " + O;
  }
  function F(i, o, l) {
    var g = i.reduce(function(S, v) {
      return v.indexOf(`
`) >= 0, S + v.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return g > 60 ? l[0] + (o === "" ? "" : o + `
 `) + " " + i.join(`,
  `) + " " + l[1] : l[0] + o + " " + i.join(", ") + " " + l[1];
  }
  function $(i) {
    return Array.isArray(i);
  }
  t.isArray = $;
  function z(i) {
    return typeof i == "boolean";
  }
  t.isBoolean = z;
  function A(i) {
    return i === null;
  }
  t.isNull = A;
  function J(i) {
    return i == null;
  }
  t.isNullOrUndefined = J;
  function R(i) {
    return typeof i == "number";
  }
  t.isNumber = R;
  function M(i) {
    return typeof i == "string";
  }
  t.isString = M;
  function u(i) {
    return typeof i == "symbol";
  }
  t.isSymbol = u;
  function c(i) {
    return i === void 0;
  }
  t.isUndefined = c;
  function x(i) {
    return j(i) && Q(i) === "[object RegExp]";
  }
  t.isRegExp = x;
  function j(i) {
    return typeof i == "object" && i !== null;
  }
  t.isObject = j;
  function X(i) {
    return j(i) && Q(i) === "[object Date]";
  }
  t.isDate = X;
  function H(i) {
    return j(i) && (Q(i) === "[object Error]" || i instanceof Error);
  }
  t.isError = H;
  function W(i) {
    return typeof i == "function";
  }
  t.isFunction = W;
  function $e(i) {
    return i === null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || typeof i == "symbol" || // ES6 symbol
    typeof i > "u";
  }
  t.isPrimitive = $e, t.isBuffer = tt;
  function Q(i) {
    return Object.prototype.toString.call(i);
  }
  function k(i) {
    return i < 10 ? "0" + i.toString(10) : i.toString(10);
  }
  var ze = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Re() {
    var i = /* @__PURE__ */ new Date(), o = [
      k(i.getHours()),
      k(i.getMinutes()),
      k(i.getSeconds())
    ].join(":");
    return [i.getDate(), ze[i.getMonth()], o].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", Re(), t.format.apply(t, arguments));
  }, t.inherits = rt, t._extend = function(i, o) {
    if (!o || !j(o))
      return i;
    for (var l = Object.keys(o), g = l.length; g--; )
      i[l[g]] = o[l[g]];
    return i;
  };
  function fe(i, o) {
    return Object.prototype.hasOwnProperty.call(i, o);
  }
})(B);
const nt = /* @__PURE__ */ qe(B);
function De(t, e, r) {
  return Ge(
    B.format(
      "[%s] [%s] [%s] - ",
      N.asString(t.startTime, r),
      t.formattedLevel,
      t.categoryName
    ),
    e
  );
}
function I(t) {
  return (e) => {
    e.$name = t.name, ie.set(t.name, { provide: e });
  };
}
var st = Object.defineProperty, it = Object.getOwnPropertyDescriptor, ot = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? it(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && st(e, r, s), s;
};
let ye = class extends C {
  /**
   * BasicLayout is a simple layouts for storing the logs. The logs are stored
   * in following format:
   * <pre>
   * [startTime] [logLevel] categoryName - message\n
   * </pre>
   *
   * @author Stephan Strittmatter
   */
  transform(t, e) {
    return De(t, void 0, e) + B.format(...[].concat(t.data));
  }
};
ye = ot([
  I({ name: "basic" })
], ye);
var at = Object.defineProperty, lt = Object.getOwnPropertyDescriptor, ct = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? lt(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && at(e, r, s), s;
};
let me = class extends C {
  /**
   * colouredLayout - taken from masylum's fork.
   * same as basicLayout, but with colours.
   */
  transform(t, e) {
    const r = t.level.toString(), n = G[r];
    return De(t, n, e) + B.format(...[].concat(t.data));
  }
};
me = ct([
  I({ name: "colored" })
], me);
var ft = Object.defineProperty, ut = Object.getOwnPropertyDescriptor, pt = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? ut(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && ft(e, r, s), s;
};
let ve = class extends C {
  transform(t, e) {
    return t.data[0];
  }
};
ve = pt([
  I({ name: "dummy" })
], ve);
function Ne(t) {
  const e = {
    ...t.context.toJSON(),
    startTime: t.startTime,
    categoryName: t.categoryName,
    level: t.level.toString()
  };
  return e.data = t.data.reduce((r, n) => typeof n == "object" ? (Object.assign(e, n), n.data ? [].concat(r, n.data) : r) : [...r, Ke(nt.format(n))], []), e;
}
var ht = Object.defineProperty, dt = Object.getOwnPropertyDescriptor, gt = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? dt(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && ht(e, r, s), s;
};
let Oe = class extends C {
  transform(t, e) {
    const r = Ne(t);
    return JSON.stringify(r) + (this.config.separator || "");
  }
};
Oe = gt([
  I({ name: "json" })
], Oe);
var yt = Object.defineProperty, mt = Object.getOwnPropertyDescriptor, vt = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? mt(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && yt(e, r, s), s;
};
let be = class extends C {
  transform(t, e) {
    return B.format(...[].concat(t.data));
  }
};
be = vt([
  I({ name: "messagePassThrough" })
], be);
var Ot = Object.defineProperty, bt = Object.getOwnPropertyDescriptor, wt = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? bt(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && Ot(e, r, s), s;
};
let we = class extends C {
  transform(t, e) {
    return Ne(t);
  }
};
we = wt([
  I({ name: "object" })
], we);
var Pe = Object.defineProperty, _t = Object.getOwnPropertyDescriptor, St = (t, e, r) => e in t ? Pe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Tt = (t, e, r, n) => {
  for (var s = n > 1 ? void 0 : n ? _t(e, r) : e, a = t.length - 1, f; a >= 0; a--)
    (f = t[a]) && (s = (n ? f(e, r, s) : f(s)) || s);
  return n && s && Pe(e, r, s), s;
}, Et = (t, e, r) => (St(t, typeof e != "symbol" ? e + "" : e, r), r), Fe = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, re = (t, e, r) => (Fe(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ne = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, se = (t, e, r, n) => (Fe(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), V, Y, q;
const At = /%(-?[0-9]+)?(\.?[0-9]+)?([[\]cdhmnpjrzxy%])(\{([^}]+)\})?|([^%]+)/, Mt = "%r %p %c - %m%n";
let _e = class extends C {
  constructor(t) {
    super(t), ne(this, V, void 0), ne(this, Y, void 0), ne(this, q, void 0), Et(this, "replaceToken", (e, r, n) => re(this, V)[e](r, n)), se(this, q, t && t.pattern || Mt), se(this, Y, t && t.tokens), se(this, V, new ae(re(this, Y), this.config.timezoneOffset).build());
  }
  /**
   *
   * @param loggingEvent
   * @param timezoneOffset
   * @returns {string}
   */
  transform(t, e) {
    let r = "", n, s = re(this, q);
    for (; (n = At.exec(s)) !== null; ) {
      const a = n[1], f = n[2], E = n[3], m = n[5], d = n[6];
      if (d)
        r += d.toString();
      else {
        const p = this.replaceToken(E, t, m);
        r += ke(p, f, a);
      }
      s = s.substr(n.index + n[0].length);
    }
    return r;
  }
};
V = /* @__PURE__ */ new WeakMap();
Y = /* @__PURE__ */ new WeakMap();
q = /* @__PURE__ */ new WeakMap();
_e = Tt([
  I({ name: "pattern" })
], _e);
class jt {
  constructor() {
    y(this, "_appenders", /* @__PURE__ */ new Map());
    y(this, "_lvls", /* @__PURE__ */ new Map());
  }
  get size() {
    return this._appenders.size;
  }
  /**
   * The `has() method returns a boolean indicating whether an element with the specified configuration name exists or not.
   * @param name Required. The key of the element to test for presence in the Map object.`
   * @returns {boolean}
   */
  has(e) {
    return this._appenders.has(e);
  }
  /**
   * The `get() method returns a specified element from a loggerAppenders.
   * @param name Required. The configuration of the element to return from the Map object.
   * @returns {LoggerAppender}
   */
  get(e) {
    return this._appenders.get(e);
  }
  /**
   * The `set()` method adds or updates an element with a specified key and value to a loggerAppenders object.
   * @param name Required. The key of the element to add to the loggerAppenders object.
   * @param config Required. The config of the element to add to the loggerAppenders object.
   * @returns {LoggerAppender}
   */
  set(e, r) {
    var E;
    const n = typeof r.type == "string" ? r.type : (E = r.type) == null ? void 0 : E.$name, s = {
      level: ["debug", "info", "trace", "error", "warn", "fatal"],
      ...r,
      type: n,
      options: r.options || {}
    };
    if (!oe.has(s.type)) {
      const m = new Error(`Appender ${s.type} doesn't exists. Check your configuration:
${JSON.stringify(s)}
`);
      throw m.name = "UNKNOW_APPENDER", m;
    }
    const a = oe.get(s.type).provide, f = new a(s);
    return "build" in f && f.build(), this._appenders.set(e, { name: e, instance: f, config: s }), this._lvls.clear(), this;
  }
  /**
   * Remove all configuration that match with the `name`.
   * @param name Required. The key of the element to remove from the loggerAppenders object.
   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
   */
  delete(e) {
    let r = this._appenders.delete(e);
    return r && this._lvls.clear(), r;
  }
  /**
   * The `clear() method removes all elements from a loggerAppenders object.
   */
  clear() {
    this._appenders.clear(), this._lvls.clear();
  }
  /**
   * The `forEach()` method executes a provided function once per each key/value pair in the loggerAppenders object, in insertion order.
   * @param callback Function to execute for each element.
   * @param thisArg Value to use as this when executing callback.
   */
  forEach(e, r) {
    this._appenders.forEach(e, r);
  }
  /**
   *
   * @returns {Array}
   */
  toArray() {
    const e = [];
    return this._appenders.forEach((r) => e.push(r)), e;
  }
  /**
   * Return all appenders that match with the given loggingLevel.
   * @param loggingLevel
   * @returns {[BaseAppender]}
   */
  byLogLevel(e) {
    const r = e.toString();
    if (this._lvls.has(r))
      return this._lvls.get(r);
    const n = this.toArray().filter(
      (s) => s.config.levels ? s.config.levels.find((a) => a.toUpperCase() === e.toString()) : !0
    ).map((s) => s.instance);
    return this._lvls.set(e.toString(), n), n;
  }
}
function K(t, e = " ") {
  let r = "";
  for (; t--; )
    r += e;
  return r;
}
function Dt(t, e) {
  let r = "┌", n = Object.keys(t);
  return n.forEach((s, a) => {
    a !== 0 && a !== n.length && (r += "┬"), r += K(t[s] + 2 * e.padding, "─");
  }), r += "┐", r;
}
function Nt(t, e) {
  let r = "└", n = Object.keys(t);
  return n.forEach((s, a) => {
    a !== 0 && a !== n.length && (r += "┴"), r += K(t[s] + 2 * e.padding, "─");
  }), r += "┘", r;
}
function Pt(t, e, r = "─") {
  let n = "";
  return Object.keys(t).forEach((s) => {
    n += "│", n += K(t[s] + 2 * e.padding, r);
  }), n += "│", n;
}
function Se(t, e, r) {
  let n = "";
  return Object.keys(e).forEach((s) => {
    n += "│ ", n += t[s], n += K(e[s] + 2 * (r.padding - 1) - t[s].length, " "), n += " ";
  }), n += "│", n;
}
function Ft(t, e = {}) {
  e.padding = e.padding || 1, e.header === void 0 && (e.header = {}, Object.keys(t[0]).forEach((s) => e.header[s] = s));
  const r = {};
  Object.keys(e.header).forEach((s) => r[s] = e.header[s].length), t.forEach((s) => {
    Object.keys(r).forEach((a) => r[a] = Math.max(("" + s[a]).length, r[a]));
  });
  let n = "";
  return n += Dt(r, e) + `
`, n += Se(e.header, r, e) + `
`, t.forEach((s) => {
    n += Pt(r, e) + `
`, n += Se(s, r, e) + `
`;
  }), n += Nt(r, e), n;
}
class ce {
  /**
   *
   */
  constructor(e = "default") {
    y(this, "_appenders", new jt());
    y(this, "_level");
    /**
     *
     */
    y(this, "_context", new Ze());
    this._name = e, this.level = "all";
  }
  get appenders() {
    return this._appenders;
  }
  get level() {
    return this._level.toString();
  }
  set level(e) {
    this._level = T.getLevel(e, "debug");
  }
  get context() {
    return this._context;
  }
  get name() {
    return this._name;
  }
  set name(e) {
    this._name = e;
  }
  /**
   * Create stack trace  the lines of least Logger.
   * @returns {string}
   */
  static createStack() {
    return new Error().stack.replace(`Error
`, "").split(`
`).filter((r, n) => n >= 2).join(`
`);
  }
  isLevelEnabled(e) {
    return this._level.isLessThanOrEqualTo(e);
  }
  /**
   * Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf() (the arguments are all passed to util.format()).
   * @param data
   * @returns {any}
   */
  debug(...e) {
    return this.write(L().DEBUG, e);
  }
  /**
   *
   * @param data
   * @returns {any}
   */
  info(...e) {
    return this.write(L().INFO, e);
  }
  /**
   *
   * @param data
   * @returns {any}
   */
  warn(...e) {
    return this.write(L().WARN, e);
  }
  /**
   * Prints to stderr with newline. Multiple arguments can be passed, with the first used as the primary
   * message and all additional used as substitution values similar to printf() (the arguments are all
   * passed to util.format()).
   * @param data
   * @returns {any}
   */
  error(...e) {
    return this.write(L().ERROR, e);
  }
  fatal(...e) {
    return this.write(L().FATAL, e);
  }
  /**
   *
   * @param data
   * @returns {Logger}
   */
  trace(...e) {
    const r = `
` + ce.createStack() + `
`;
    return e.push(r), this.write(L().TRACE, e);
  }
  /**
   *
   */
  start() {
    return this.level = "ALL", this;
  }
  /**
   *
   */
  stop() {
    return this.level = "OFF", this;
  }
  /**
   *
   * @returns {Promise<any[]>}
   */
  shutdown() {
    this.stop();
    const e = this.appenders.toArray().filter((r) => !!r.instance.shutdown).map((r) => r.instance.shutdown());
    return Promise.all(e);
  }
  /**
   *
   * @param list
   * @param settings
   */
  drawTable(e, r = {}) {
    return Ft(e, r);
  }
  /**
   *
   * @param list
   * @param settings
   * @returns {Logger}
   */
  printTable(e, r = {}) {
    return this.info(`
${this.drawTable(e, r)}`), this;
  }
  /**
   *
   * @returns {Logger}
   */
  write(e, r) {
    if (!this.isLevelEnabled(e))
      return this;
    const n = new Ve(this._name, e, r, this._context);
    return this.appenders.byLogLevel(e).forEach((s) => {
      s.write(n);
    }), this;
  }
}
const $t = new ce("default");
$t.appenders.set("console", { type: "console", levels: ["info", "debug", "trace", "fatal", "error", "warn"] });
export {
  $t as $log,
  Be as Appender,
  oe as AppendersRegistry,
  Ue as BaseAppender,
  C as BaseLayout,
  ye as BasicLayout,
  me as ColoredLayout,
  ge as ConsoleAppender,
  ve as DummyLayout,
  Oe as JsonLayout,
  G as LOG_COLORS,
  I as Layout,
  ae as LayoutReplacer,
  de as Layouts,
  ie as LayoutsRegistry,
  Ze as LogContext,
  Ve as LogEvent,
  T as LogLevel,
  ce as Logger,
  jt as LoggerAppenders,
  be as MessagePassThroughLayout,
  we as ObjectLayout,
  _e as PatternLayout,
  Nt as buildEndLine,
  Pt as buildLine,
  Se as buildLineData,
  Dt as buildStartLine,
  K as charRepeater,
  Ge as colorize,
  je as colorizeEnd,
  Me as colorizeStart,
  Ft as drawTable,
  et as format,
  L as levels,
  Ne as logEventToObject,
  Qe as pad,
  Ke as removeColors,
  De as timestampLevelAndCategory,
  Xe as truncate,
  ke as truncateAndPad
};
