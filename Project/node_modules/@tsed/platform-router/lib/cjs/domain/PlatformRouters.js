"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformRouters = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const useContextHandler_1 = require("../utils/useContextHandler");
const PlatformLayer_1 = require("./PlatformLayer");
const PlatformRouter_1 = require("./PlatformRouter");
let AUTO_INC = 0;
function getInjectableRouter(injector, provider) {
    return injector.get(provider.tokenRouter);
}
function createTokenRouter(provider) {
    return (provider.tokenRouter = provider.tokenRouter || `${provider.name}_ROUTER_${AUTO_INC++}`);
}
function createInjectableRouter(injector, provider) {
    const tokenRouter = createTokenRouter(provider);
    if (injector.has(tokenRouter)) {
        return getInjectableRouter(injector, provider);
    }
    const router = injector.invoke(PlatformRouter_1.PlatformRouter);
    router.provider = provider;
    return injector
        .add(tokenRouter, {
        useValue: router
    })
        .invoke(tokenRouter);
}
di_1.GlobalProviders.createRegistry(di_1.ProviderType.CONTROLLER, di_1.ControllerProvider, {
    onInvoke(provider, locals, { injector }) {
        const router = createInjectableRouter(injector, provider);
        locals.set(PlatformRouter_1.PlatformRouter, router);
    }
});
let PlatformRouters = class PlatformRouters {
    injector;
    hooks = new core_1.Hooks();
    allowedVerbs = schema_1.OPERATION_HTTP_VERBS;
    constructor(injector) {
        this.injector = injector;
    }
    prebuild() {
        this.injector.getProviders(di_1.ProviderType.CONTROLLER).forEach((provider) => {
            createInjectableRouter(this.injector, provider);
        });
    }
    from(token, parentMiddlewares = []) {
        const { injector } = this;
        const provider = injector.getProvider(token);
        if (!provider) {
            throw new Error("Token not found in the provider registry");
        }
        const router = createInjectableRouter(injector, provider);
        if (router.isBuilt()) {
            return router;
        }
        const useBefore = (0, core_1.getValue)(provider, "middlewares.useBefore", []);
        const { children } = provider;
        (0, schema_1.getOperationsRoutes)(provider.token, { allowedVerbs: this.allowedVerbs }).forEach((operationRoute) => {
            const { endpoint } = operationRoute;
            const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares } = endpoint;
            const useBefore = (0, core_1.getValue)(provider, "middlewares.useBefore", []);
            const use = (0, core_1.getValue)(provider, "middlewares.use", []);
            const useAfter = (0, core_1.getValue)(provider, "middlewares.useAfter", []);
            let handlers = this.hooks.alter("alterEndpointHandlers", {
                before: [...parentMiddlewares, ...useBefore, ...beforeMiddlewares, ...use, ...mldwrs],
                endpoint,
                after: [...afterMiddlewares, ...useAfter]
            }, [operationRoute], this);
            handlers = this.sortHandlers(handlers);
            router.addRoute(operationRoute.method, operationRoute.path || "", [
                (0, useContextHandler_1.useContextHandler)(($ctx) => {
                    $ctx.endpoint = operationRoute.endpoint;
                }),
                ...[...handlers.before, handlers.endpoint, ...handlers.after]
            ], operationRoute);
        });
        const middlewares = [...parentMiddlewares, ...useBefore];
        children.forEach((token) => {
            const nested = this.from(token, middlewares);
            router.use(nested);
        });
        return router;
    }
    getLayers(router) {
        return this.flatMapLayers(router.layers);
    }
    sortHandlers(handlers) {
        const get = (token) => {
            return this.injector.getProvider(token)?.priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        handlers.before = handlers.before.sort(sort);
        handlers.after = handlers.after.sort(sort);
        return handlers;
    }
    flatMapLayers(layers) {
        return layers
            .flatMap((layer) => {
            if (layer.router) {
                return this.flatMapLayers(layer.layers).map((subLayer) => {
                    return new PlatformLayer_1.PlatformLayer({
                        ...subLayer,
                        path: (0, schema_1.concatPath)(layer.path, subLayer.path)
                    });
                });
            }
            return new PlatformLayer_1.PlatformLayer(layer);
        })
            .map((layer) => {
            const handlers = layer.handlers.map((handlerMetadata) => {
                // set path on handler metadata to retrieve it later in $ctx
                handlerMetadata.path = layer.path;
                if (handlerMetadata.isRawFn()) {
                    return handlerMetadata.handler;
                }
                return this.hooks.alter("alterHandler", handlerMetadata);
            });
            layer.set(handlers);
            return layer;
        });
    }
};
PlatformRouters = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], PlatformRouters);
exports.PlatformRouters = PlatformRouters;
//# sourceMappingURL=PlatformRouters.js.map