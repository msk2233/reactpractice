"use strict";
var PlatformRouter_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformRouter = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const formatMethod_1 = require("../utils/formatMethod");
const PlatformHandlerMetadata_1 = require("./PlatformHandlerMetadata");
const PlatformLayer_1 = require("./PlatformLayer");
function printHandler(handler) {
    return handler.toString().split("{")[0].trim();
}
let PlatformRouter = PlatformRouter_1 = class PlatformRouter {
    injector;
    layers = [];
    provider;
    #isBuilt = false;
    constructor(injector) {
        this.injector = injector;
    }
    use(...handlers) {
        const layer = handlers.reduce((layer, item) => {
            if ((0, core_1.isString)(item) || item instanceof RegExp) {
                layer.path = item;
                layer.basePath = item;
            }
            else {
                if (item instanceof PlatformRouter_1) {
                    layer.router = item;
                    layer.setLayers(item.layers);
                    if (!this.provider && item.provider) {
                        layer.path = (0, schema_1.concatPath)(layer.path, item.provider.path);
                    }
                    else {
                        layer.path = layer.path || item.provider.path;
                    }
                }
                else {
                    item = PlatformHandlerMetadata_1.PlatformHandlerMetadata.from(this.injector, item);
                }
                layer.handlers.push(item);
            }
            return layer;
        }, new PlatformLayer_1.PlatformLayer({
            method: "use",
            basePath: this.provider?.path || "/",
            provider: this.provider
        }));
        this.layers.push(layer);
        return this;
    }
    addRoute(method, path, handlers, opts = {}) {
        const layer = new PlatformLayer_1.PlatformLayer({
            provider: this.provider,
            method: (0, formatMethod_1.formatMethod)(method),
            path,
            handlers: handlers.map((input) => {
                return PlatformHandlerMetadata_1.PlatformHandlerMetadata.from(this.injector, input, opts);
            }),
            opts
        });
        this.layers.push(layer);
        return this;
    }
    all(path, ...handlers) {
        return this.addRoute("all", path, handlers);
    }
    get(path, ...handlers) {
        return this.addRoute("get", path, handlers);
    }
    post(path, ...handlers) {
        return this.addRoute("post", path, handlers);
    }
    put(path, ...handlers) {
        return this.addRoute("put", path, handlers);
    }
    delete(path, ...handlers) {
        return this.addRoute("delete", path, handlers);
    }
    patch(path, ...handlers) {
        return this.addRoute("patch", path, handlers);
    }
    head(path, ...handlers) {
        return this.addRoute("head", path, handlers);
    }
    options(path, ...handlers) {
        return this.addRoute("options", path, handlers);
    }
    statics(path, options) {
        return this.addRoute("statics", path, [], options);
    }
    inspect() {
        return this.layers.map((layer) => {
            const obj = layer.inspect();
            return {
                ...obj,
                handlers: obj.handlers.map(printHandler),
                path: (0, schema_1.concatPath)(this.provider?.path, obj.path)
            };
        });
    }
    isBuilt() {
        if (this.#isBuilt) {
            return true;
        }
        this.#isBuilt = true;
        return false;
    }
};
PlatformRouter = PlatformRouter_1 = tslib_1.__decorate([
    (0, di_1.Injectable)(),
    (0, di_1.Scope)(di_1.ProviderScope.INSTANCE),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], PlatformRouter);
exports.PlatformRouter = PlatformRouter;
//# sourceMappingURL=PlatformRouter.js.map