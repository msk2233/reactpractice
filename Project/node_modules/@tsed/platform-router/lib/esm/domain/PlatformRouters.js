import { __decorate, __metadata } from "tslib";
import { getValue, Hooks } from "@tsed/core";
import { ControllerProvider, GlobalProviders, Injectable, InjectorService, ProviderType } from "@tsed/di";
import { concatPath, getOperationsRoutes, OPERATION_HTTP_VERBS } from "@tsed/schema";
import { useContextHandler } from "../utils/useContextHandler.js";
import { PlatformLayer } from "./PlatformLayer.js";
import { PlatformRouter } from "./PlatformRouter.js";
let AUTO_INC = 0;
function getInjectableRouter(injector, provider) {
    return injector.get(provider.tokenRouter);
}
function createTokenRouter(provider) {
    return (provider.tokenRouter = provider.tokenRouter || `${provider.name}_ROUTER_${AUTO_INC++}`);
}
function createInjectableRouter(injector, provider) {
    const tokenRouter = createTokenRouter(provider);
    if (injector.has(tokenRouter)) {
        return getInjectableRouter(injector, provider);
    }
    const router = injector.invoke(PlatformRouter);
    router.provider = provider;
    return injector
        .add(tokenRouter, {
        useValue: router
    })
        .invoke(tokenRouter);
}
GlobalProviders.createRegistry(ProviderType.CONTROLLER, ControllerProvider, {
    onInvoke(provider, locals, { injector }) {
        const router = createInjectableRouter(injector, provider);
        locals.set(PlatformRouter, router);
    }
});
let PlatformRouters = class PlatformRouters {
    injector;
    hooks = new Hooks();
    allowedVerbs = OPERATION_HTTP_VERBS;
    constructor(injector) {
        this.injector = injector;
    }
    prebuild() {
        this.injector.getProviders(ProviderType.CONTROLLER).forEach((provider) => {
            createInjectableRouter(this.injector, provider);
        });
    }
    from(token, parentMiddlewares = []) {
        const { injector } = this;
        const provider = injector.getProvider(token);
        if (!provider) {
            throw new Error("Token not found in the provider registry");
        }
        const router = createInjectableRouter(injector, provider);
        if (router.isBuilt()) {
            return router;
        }
        const useBefore = getValue(provider, "middlewares.useBefore", []);
        const { children } = provider;
        getOperationsRoutes(provider.token, { allowedVerbs: this.allowedVerbs }).forEach((operationRoute) => {
            const { endpoint } = operationRoute;
            const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares } = endpoint;
            const useBefore = getValue(provider, "middlewares.useBefore", []);
            const use = getValue(provider, "middlewares.use", []);
            const useAfter = getValue(provider, "middlewares.useAfter", []);
            let handlers = this.hooks.alter("alterEndpointHandlers", {
                before: [...parentMiddlewares, ...useBefore, ...beforeMiddlewares, ...use, ...mldwrs],
                endpoint,
                after: [...afterMiddlewares, ...useAfter]
            }, [operationRoute], this);
            handlers = this.sortHandlers(handlers);
            router.addRoute(operationRoute.method, operationRoute.path || "", [
                useContextHandler(($ctx) => {
                    $ctx.endpoint = operationRoute.endpoint;
                }),
                ...[...handlers.before, handlers.endpoint, ...handlers.after]
            ], operationRoute);
        });
        const middlewares = [...parentMiddlewares, ...useBefore];
        children.forEach((token) => {
            const nested = this.from(token, middlewares);
            router.use(nested);
        });
        return router;
    }
    getLayers(router) {
        return this.flatMapLayers(router.layers);
    }
    sortHandlers(handlers) {
        const get = (token) => {
            return this.injector.getProvider(token)?.priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        handlers.before = handlers.before.sort(sort);
        handlers.after = handlers.after.sort(sort);
        return handlers;
    }
    flatMapLayers(layers) {
        return layers
            .flatMap((layer) => {
            if (layer.router) {
                return this.flatMapLayers(layer.layers).map((subLayer) => {
                    return new PlatformLayer({
                        ...subLayer,
                        path: concatPath(layer.path, subLayer.path)
                    });
                });
            }
            return new PlatformLayer(layer);
        })
            .map((layer) => {
            const handlers = layer.handlers.map((handlerMetadata) => {
                // set path on handler metadata to retrieve it later in $ctx
                handlerMetadata.path = layer.path;
                if (handlerMetadata.isRawFn()) {
                    return handlerMetadata.handler;
                }
                return this.hooks.alter("alterHandler", handlerMetadata);
            });
            layer.set(handlers);
            return layer;
        });
    }
};
PlatformRouters = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [InjectorService])
], PlatformRouters);
export { PlatformRouters };
//# sourceMappingURL=PlatformRouters.js.map